<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<HTML><HEAD><TITLE>PNL Wrappers: Reference Manual</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1251"><LINK 
href="style.css" type=text/css charset=ISO-8859-1 
rel=STYLESHEET>
<META content="Microsoft FrontPage 4.0" name=GENERATOR></HEAD>
<BODY>
<center><table cellspacing=0 cellpadding=5 width="90%" bgcolor="#6a9bed" nosave >
<tr nosave>
<td nosave>
<center><i><font color="#000000"><font size=+4>
PNL Wrappers: Reference Manual
</font></font></i></center>
</td>
</tr>
</table></center>
<HR>

<P>
<UL>
  <LI><A 
  href="#decl_Class_BayesNet">Class BayesNet</A> 
  <UL>
    <LI><A 
    href="#decl_AddArc">AddArc</A> 

    <LI><A 
    href="#decl_AddEvidToBuf">AddEvidToBuf</A> 

    <LI><A 
    href="#decl_AddNode">AddNode</A> 

    <LI><A 
    href="#decl_BayesNet">BayesNet</A> 

    <LI><A 
    href="#decl_ClearEvid">ClearEvid</A> 

    <LI><A 
    href="#decl_ClearEvidBuf">ClearEvidBuf</A> 

    <LI><A 
    href="#decl_CurEvidToBuf">CurEvidToBuf</A> 

    <LI><A 
    href="#decl_DelArc">DelArc</A> 

    <LI><A 
    href="#decl_DelNode">DelNode</A> 

    <LI><A 
    href="#decl_EditEvidence">EditEvidence</A> 

    <LI><A 
    href="#decl_GenerateEvidences">GenerateEvidences</A> 

    <LI><A 
    href="#decl_GetChildren">GetChildren</A> 

    <LI><A 
    href="#decl_GetCurEvidenceLogLik">GetCurEvidenceLogLik</A> 

    <LI><A 
    href="#decl_GetEMLearningCriterionValue">GetEMLearningCriterionValue</A> 

    <LI><A 
    href="#decl_GetEvidBufLogLik">GetEvidBufLogLik</A> 

    <LI><A 
    href="#decl_GetGaussianMean">GetGaussianMean</A> 

    <LI><A 
    href="#decl_GetGaussianCovar">GetGaussianCovar</A> 

    <LI><A 
    href="#decl_GetGaussianWeights">GetGaussianWeights</A> 

	<LI><A 
    href="#decl_GetJPD">GetJPD</A> 

    <LI><A 
    href="#decl_GetMPE">GetMPE</A> 

    <LI><A 
    href="#decl_GetNeighbours">GetNeighbours</A> 

    <LI><A 
    href="#decl_GetNodeType">GetNodeType</A> 

    <LI><A 
    href="#decl_GetParents">GetParents</A> 

    <LI><A 
    href="#decl_GetPNLEvidence">GetPNLEvidence</A> 

    <LI><A 
    href="#decl_GetProperty">GetProperty</A> 

    <LI><A 
    href="#decl_GetPTabular">GetPTabular</A> 

    <LI><A 
    href="#decl_Inference">Inference</A> 

    <LI><A 
    href="#decl_Learning">Learning</A> 

    <LI><A 
    href="#decl_LearnParameters">LearnParameters</A> 

    <LI><A 
    href="#decl_LearnStructure">LearnStructure</A> 

    <LI><A 
    href="#decl_LoadEvidBuf">LoadEvidBuf</A> 

    <LI><A 
    href="#decl_LoadNet">LoadNet</A> 

    <LI><A 
    href="#decl_MaskEvidBuf">MaskEvidBuf</A> 

    <LI><A 
    href="#decl_Model">Model</A> 

    <LI><A 
    href="#decl_SaveEvidBuf">SaveEvidBuf</A> 

    <LI><A 
    href="#decl_SaveNet">SaveNet</A> 

    <LI><A 
    href="#decl_SetPGaussian">SetPGaussian</A> 

    <LI><A 
    href="#decl_SetProperty">SetProperty</A> 

    <LI><A 
    href="#decl_SetPTabular">SetPTabular</A> 

    </LI></UL>
  </UL>
<UL>
  <LI><A 
  href="#decl_Class_DBN">Class DBN</A> 
  <UL>
    <LI><A 
    href="#decl_AddArc_DBN">AddArc</A> 

    <LI><A 
    href="#decl_AddEvidToBuf_DBN">AddEvidToBuf</A> 

    <LI><A 
    href="#decl_AddNode_DBN">AddNode</A> 

    <LI><A 
    href="#decl_DBN">DBN</A> 

    <LI><A 
    href="#decl_ClearEvid_DBN">ClearEvid</A> 

    <LI><A 
    href="#decl_ClearEvidBuf_DBN">ClearEvidBuf</A> 

    <LI><A 
    href="#decl_CurEvidToBuf_DBN">CurEvidToBuf</A> 

    <LI><A 
    href="#decl_DelArc_DBN">DelArc</A> 

    <LI><A 
    href="#decl_DelNode_DBN">DelNode</A> 

    <LI><A 
    href="#decl_EditEvidence_DBN">EditEvidence</A> 

    <LI><A 
    href="#decl_GenerateEvidences_DBN">GenerateEvidences</A> 

    <LI><A 
    href="#decl_GetEMLearningCriterionValue_DBN">GetEMLearningCriterionValue</A> 	

    <LI><A 
    href="#decl_GetChildren_DBN">GetChildren</A> 

    <LI><A 
    href="#decl_GetGaussianMean_DBN">GetGaussianMean</A> 

    <LI><A 
    href="#decl_GetGaussianCovar_DBN">GetGaussianCovar</A> 

    <LI><A 
    href="#decl_GetJPD_DBN">GetJPD</A> 

    <LI><A 
    href="#decl_GetMPE_DBN">GetMPE</A> 

    <LI><A 
    href="#decl_GetNeighbours_DBN">GetNeighbours</A> 

    <LI><A 
    href="#decl_GetNodeType_DBN">GetNodeType</A> 

    <LI><A 
    href="#decl_GetParents_DBN">GetParents</A> 

    <LI><A 
    href="#decl_GetPNLEvidences_DBN">GetPNLEvidences</A> 

    <LI><A 
    href="#decl_GetProperty_DBN">GetProperty</A> 

    <LI><A 
    href="#decl_GetNumSlices_DBN">GetNumSlices</A> 

    <LI><A 
    href="#decl_GetPTabular_DBN">GetPTabular</A> 

    <LI><A 
    href="#decl_Inference_DBN">Inference</A> 

    <LI><A 
    href="#decl_Learning_DBN">Learning</A> 

    <LI><A 
    href="#decl_LearnParameters_DBN">LearnParameters</A> 

    <LI><A 
    href="#decl_LoadEvidBuf_DBN">LoadEvidBuf</A> 

    <LI><A 
    href="#decl_LoadNet_DBN">LoadNet</A> 

    <LI><A 
    href="#decl_Model_DBN">Model</A> 

    <LI><A 
    href="#decl_SaveEvidBuf_DBN">SaveEvidBuf</A> 

    <LI><A 
    href="#decl_SaveNet_DBN">SaveNet</A> 

    <LI><A 
    href="#decl_SetPGaussian_DBN">SetPGaussian</A> 

    <LI><A 
    href="#decl_SetProperty_DBN">SetProperty</A> 

    <LI><A 
    href="#decl_SetPTabular_DBN">SetPTabular</A> 

    <LI><A 
    href="#decl_SetNumSlices_DBN">SetNumSlices</A> 

    <LI><A 
     href="#decl_Unroll_DBN">Unroll</A> 	

    </LI></UL>
  </UL>
<UL>
  <LI><A 
  href="#decl_Class_LIMID">Class LIMID</A> 
  <UL>
    <LI><A 
    href="#decl_AddArc_LIMID">AddArc</A> 

    <LI><A 
    href="#decl_AddNode_LIMID">AddNode</A> 

    <LI><A 
    href="#decl_DelArc_LIMID">DelArc</A> 

    <LI><A 
    href="#decl_DelNode_LIMID">DelNode</A> 

    <LI><A 
    href="#decl_GetExpectation">GetExpectation</A> 
    
    <LI><A 
    href="#decl_GetPChance">GetPChance</A> 

    <LI><A 
    href="#decl_GetPDecision">GetPDecision</A> 

    <LI><A 
    href="#decl_GetPolitics">GetPolitics</A> 

    <LI><A 
    href="#decl_GetProperty_LIMID">GetProperty</A> 

    <LI><A 
    href="#decl_GetValueCost">GetValueCost</A>

    <LI><A 
    href="#decl_Inference_LIMID">Inference</A>

    <LI><A 
    href="#decl_LIMID">LIMID</A> 
 
    <LI><A 
    href="#decl_LoadNet_LIMID">LoadNet</A> 

    <LI><A 
    href="#decl_Model_LIMID">Model</A>

    <LI><A 
    href="#decl_SaveNet_LIMID">SaveNet</A> 
    
    <LI><A 
    href="#decl_SetPChance">SetPChance</A> 

    <LI><A 
    href="#decl_SetPDecision">SetPDecision</A> 

    <LI><A 
    href="#decl_SetProperty_LIMID">SetProperty</A> 

    <LI><A 
    href="#decl_SetValueCost">SetValueCost</A>  

    </LI></UL>
  </UL>
<UL>
  <LI><A 
  href="#decl_Class_MRF">Class MRF</A> 
  <UL>
    <LI><A 
    href="#decl_AddEvidToBuf_MRF">AddEvidToBuf</A> 

    <LI><A 
    href="#decl_AddNode_MRF">AddNode</A> 

    <LI><A 
    href="#decl_MRF">MRF</A> 

    <LI><A 
    href="#decl_ClearEvid_MRF">ClearEvid</A> 

    <LI><A 
    href="#decl_ClearEvidBuf_MRF">ClearEvidBuf</A> 

    <LI><A 
    href="#decl_CurEvidToBuf_MRF">CurEvidToBuf</A>

    <LI><A 
    href="#decl_DelNode_MRF">DelNode</A> 

    <LI><A 
    href="#decl_DestroyClique_MRF">DestroyClique</A> 

    <LI><A 
    href="#decl_EditEvidence_MRF">EditEvidence</A> 

    <LI><A 
    href="#decl_GenerateEvidences_MRF">GenerateEvidences</A> 

    <LI><A 
    href="#decl_GetJPD_MRF">GetJPD</A> 

    <LI><A 
    href="#decl_GetMPE_MRF">GetMPE</A> 

    <LI><A 
    href="#decl_GetNeighbours_MRF">GetNeighbours</A> 

    <LI><A 
    href="#decl_GetNodeType_MRF">GetNodeType</A> 

    <LI><A 
    href="#decl_GetNumberOfCliques_MRF">GetNumberOfCliques</A> 

    <LI><A 
    href="#decl_GetNumberOfNodes_MRF">GetNumberOfNodes</A>

    <LI><A 
    href="#decl_GetPNLEvidence_MRF">GetPNLEvidence</A>  

    <LI><A 
    href="#decl_GetProperty_MRF">GetProperty</A> 

    <LI><A 
    href="#decl_GetPTabular_MRF">GetPTabular</A> 

    <LI><A 
    href="#decl_Inference_MRF">Inference</A> 

    <LI><A 
    href="#decl_Learning_MRF">Learning</A> 

    <LI><A 
    href="#decl_LearnParameters_MRF">LearnParameters</A> 

    <LI><A 
    href="#decl_LoadEvidBuf_MRF">LoadEvidBuf</A> 

    <LI><A 
    href="#decl_LoadNet_MRF">LoadNet</A> 

    <LI><A 
    href="#decl_MaskEvidBuf_MRF">MaskEvidBuf</A> 

    <LI><A 
    href="#decl_Model_MRF">Model</A> 

    <LI><A 
    href="#decl_SaveEvidBuf_MRF">SaveEvidBuf</A> 

    <LI><A 
    href="#decl_SaveNet_MRF">SaveNet</A> 

    <LI><A 
    href="#decl_SetClique_MRF">SetClique</A> 

    <LI><A 
    href="#decl_SetProperty_MRF">SetProperty</A> 

    <LI><A 
    href="#decl_SetPTabular_MRF">SetPTabular</A> 

    </LI></UL>
  </UL>
<HR>

<H2><A name=decl_Class_BayesNet>Class BayesNet</A></H2>
<HR>

<P>Class BayesNet implements all functionality required for work with bayesian networks. 
The following functional groups can be distinguished:
<UL>
    <LI>Network creation (addition/deletion of nodes and arcs)<BR>
    <A href="#decl_AddNode">AddNode</A>,
    <A href="#decl_DelNode">DelNode</A>,
    <A href="#decl_AddArc">AddArc</A>,
    <A href="#decl_DelArc">DelArc</A>.
    </LI>
    <LI>Setting/getting parameters<BR>
    <A href="#decl_SetPTabular">SetPTabular</A>,
    <A href="#decl_GetPTabular">GetPTabular</A>,
    <A href="#decl_SetPGaussian">SetPGaussian</A>,
    <A href="#decl_GetGaussianMean">GetGaussianMean</A> ,
    <A href="#decl_GetGaussianCovar">GetGaussianCovar</A>,
    <A href="#decl_GetGaussianWeights">GetGaussianWeights</A>,
    <A href="#decl_EditEvidence">EditEvidence</A>,
    <A href="#decl_ClearEvid">ClearEvid</A>,
    <A href="#decl_CurEvidToBuf">CurEvidToBuf</A>,
    <A href="#decl_AddEvidToBuf">AddEvidToBuf</A>,
    <A href="#decl_ClearEvidBuf">ClearEvidBuf</A>,
    <A href="#decl_GetChildren">GetChildren</A>,
    <A href="#decl_GetParents">GetParents</A>,
    <A href="#decl_GetNeighbours">GetNeighbours</A>,
    <A href="#decl_SetProperty">SetProperty</A>,
    <A href="#decl_GetProperty">GetProperty</A>,
    <A href="#decl_GetPNLEvidence">GetPNLEvidence</A>,
    <A href="#decl_Inference">Inference</A>,
    <A href="#decl_Learning">Learning</A>,
    <A href="#decl_Model">Model</A>
    </LI>
    <LI>Learning parameters<BR>
    <A href="#decl_LearnParameters">LearnParameters</A>
    </LI>
    <LI>Learning network structure<BR>
    <A href="#decl_LearnStructure">LearnStructure</A>
    </LI>
    <LI>Inference in network<BR>
    <A href="#decl_GetJPD">GetJPD</A>,
    <A href="#decl_GetMPE">GetMPE</A>
    </LI>
    <LI>Data sampling<BR>
    <A href="#decl_GenerateEvidences">GenerateEvidences</A>
    </LI>
    <LI>File I/O<BR>
    <A href="#decl_LoadNet">LoadNet</A>,
    <A href="#decl_SaveNet">SaveNet</A>,
    <A href="#decl_LoadEvidBuf">LoadEvidBuf</A>,
    <A href="#decl_SaveEvidBuf">SaveEvidBuf</A>
    </LI>
    <LI>more...</LI>
</UL>
<HR>


<H3><A name=decl_BayesNet>BayesNet</A></H3>
<P class=Blurb>Constructor</P>
<font class="interface">
BayesNet();
</font>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">BayesNet class has only default constructor.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Create empty Bayessian net:
</p>
<p class="example">
BayesNet net;
</p>
<HR>

<H3><A name=decl_AddNode>AddNode</A></H3>
<P class=Blurb>Adds nodes</P>
<font class="interface">
void AddNode(TokArr nodes, TokArr subnodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>List of nodes with nodes type (discrete or continuous) specifying. 
  <DT>subnodes
  <DD>Array of values that nodes can take (or names of dimensions for continuous nodes). 
</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds one or several nodes with the same probable states into the network.</p>
<H5>
Example of usage
</H5>
<p class="description">
Add one discrete node "NodeA" with states "true" and "false" to bayes net:
</p>
<p class="example">
net.AddNode(discrete^"NodeA", "true false");
</p>
<p class="description">
Add one-dimensional continuous node "NodeA" to Bayessian net:
</p>
<p class="example">
net.AddNode(continuous^"NodeA", "dim1");
</p>
<p class="description">
Add discrete nodes "NodeA" and "NodeB" with states "true" and "false" to bayes net:
</p>
<p class="example">
net.AddNode(discrete^"NodeA NodeB", "true false");
</p>
<p class="description">
Add multivariate nodes "NodeA" with 2 dimensions "dim1" and "dim2" to bayes net:
</p>
<p class="example">
net.AddNodee(continuous^"NodeA", "dim1 dim2");
</p>
<HR>

<H3><A name=decl_DelNode>DelNode</A></H3>
<P class=Blurb>Deletes nodes</P>
<font class="interface">
void DelNode(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of names of nodes to delete. 
  </DD></DL>
<H5>Discussion</H5>
<p class="description">The function deletes one or several nodes from network together with all adjacent edges. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Delete nodes "NodeA" and "NodeB" from Bayessian net:
</p>
<p class="example">
net.DelNode("NodeA NodeB");
</P>
<HR>

<H3><A name=decl_GetNodeType>GetNodeType</A></H3>
<P class=Blurb>Returns types of the given nodes</P>
<font class="interface">
TokArr GetNodeType(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes whose type is interesting. 
</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns array of types (discrete or continuous) of given nodes.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get array of types of nodes "NodeA" and "NodeB":
</p>
<p class="example">
   TokArr nodeTypes = net.GetNodeType("NodeA NodeB");
</P>
<HR>

<H3><A name=decl_AddArc>AddArc</A></H3>
<P class=Blurb>Adds arc</P>
<font class="interface">
void AddArc(TokArr from, TokArr to);
</font>
<H5>Arguments</H5>
<DL>
  <DT>from
  <DD>Array of starting nodes of the arcs. 
  <DT>to
  <DD>Array of ending nodes of the arcs</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds one or several arcs to the network. Each starting node is connected with each ending node.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Add edge from node "NodeA" to node "NodeB":
</p>
<p class="example">
net.AddArc("NodeA", "NodeB");
</P>
<p class="description">
Add two edges: from "NodeA" to "NodeB" and from "NodeA" to "NodeC":
</p>
<p class="example">
net.AddArc("NodeA", "NodeB NodeC");
</P>
<p class="description">
Add four edges: from "NodeA" to "NodeC", from "NodeA" to "NodeD", from "NodeB" to "NodeC" and from "NodeB" to "NodeD":
</p>
<p class="example">
net.AddArc("NodeA NodeB", "NodeC NodeD");
</P>
<HR>

<H3><A name=decl_DelArc>DelArc</A></H3>
<P class=Blurb>Deletes arcs</P>
<font class="interface">
void DelArc(TokArr from, TokArr to);
</font>
<H5>Arguments</H5>
<DL>
  <DT>from
  <DD>Array of starting nodes of the arcs to delete. 
  <DT>to
  <DD>Array of ending nodes of the arcs to delete. 
  </DD></DL>
<H5>Discussion</H5>
<p class="description">The function deletes one or several arcs from the network. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Delete edge from node "NodeA" to node "NodeB":
</p>
<p class="example">
net.DelArc("NodeA", "NodeB");
</P>
<p class="description">
Delete following two edges if they exist: from "NodeA" to "NodeB" and from "NodeA" to "NodeC":
</p>
<p class="example">
net.DelArc("NodeA", "NodeB NodeC");
</P>
<p class="description">
Delete all edges with starting node "NodeA" or "NodeB" and ending node "NodeC" or "NodeD":
</p>
<p class="example">
net.DelArc("NodeA NodeB", "NodeC NodeD");
</P>
<HR>

<H3><A 
name=decl_GetNeighbours>GetNeighbours</A></H3>
<P class=Blurb>Returns list of neighbours for given node. 
</P>
<font class="interface">
TokArr GetNeighbours(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>One or several nodes whose neighbours are need.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns list of neighbours for given node or some nodes. If neighbours of several nodes are demanded then neighbors of every node are in the result.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get neighbors of node "NodeA":
</p>
<p class="example">
TokArr NodeANeighbors = net.GetNeighbours("NodeA");
</P>
<p class="description">
Get neighbors of node "NodeA" and neighbors of node "NodeB". If node "NodeC" is neighbor of both "NodeA" and "NodeB" then it is once in result list of neighbors:
</p>
<p class="example">
TokArr NodeAandBNeighbors = net.GetNeighbours("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_GetParents>GetParents</A></H3>
<P class=Blurb>Returns list of parents for given node. 
</P>
<font class="interface">
TokArr GetParents(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>One or several nodes whose parents are need.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns list of parents for given node or some nodes. If parents of several nodes are demanded then parents of every node are in the result.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get parents of node "NodeA":
</p>
<p class="example">
TokArr NodeAParents = net.GetParents("NodeA");
</P>
<p class="description">
Get parents of node "NodeA" and parents of node "NodeB". If node "NodeC" is parent of both "NodeA" and "NodeB" then it is once in result list of parents:
</p>
<p class="example">
TokArr NodeAandBParents = net.GetParents("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_GetChildren>GetChildren</A></H3>
<P class=Blurb>Returns list of children for given node. 
</P>
<font class="interface">
TokArr GetChildren(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>One or several nodes whose children are need.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns list of children for given node or some nodes.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get children of node "NodeA":
</p>
<p class="example">
TokArr NodeAChildren = net.GetChildren("NodeA");
</P>
<p class="description">
Get children of node "NodeA" and children of node "NodeB". If node "NodeC" is child both "NodeA" and "NodeB" then it is once in result list of children:
</p>
<p class="example">
TokArr NodeAandBChildren = net.GetChildren("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_SetPTabular>SetPTabular</A></H3>
<P class=Blurb>Assigns probability to one or several values of one discrete node 
</P>
<font class="interface">
void SetPTabular(TokArr value, TokArr prob, TokArr parentValue = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>value
  <DD>Array of node values for wich probabilities are set. 
  <DT>prob
  <DD>Array of values of probabilities.
  <DT>parentValue
  <DD>Array of values of discrete parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets [conditional] probability for one or several values of the discrete node 
[for given values of parents]. Sizes of values array and probabilities array must be the same. While distribution 
of probabilities is not specified it is considered uniform.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's node "NodeA" has no parents and can take on two values: "true" and "false". Its distribution of probabilities is unconditional. 
</p>
<p class="example">
net.SetPTabular("NodeA^true NodeA^false", "0.7 0.3");
</P>
<p class="description">
Let's node "NodeB" can take on values "true" and "false" too and has only one parent "NodeA". Distribution of 
probabilities of "NodeB" is conditional. It is necessary to call SetPTabular method for each configuration of 
parents values:  
</p>
<p class="example">
net.SetPTabular("NodeB^true NodeB^false", "0.99 0.01", "NodeA^true");<br>
net.SetPTabular("NodeB^true NodeB^false", "0.4 0.6", "NodeA^false");
</P>
<HR>

<H3><A 
name=decl_GetPTabular>GetPTabular</A></H3>
<P class=Blurb>Returns probability of discrete node 
</P>
<font class="interface">
TokArr GetPTabular(TokArr node, TokArr parents = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>node
  <DD>Name of node or array of node values whose probabilities are needed. 
  <DT>parents
  <DD>Values of parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns probability of discrete node. If values of parents are given then probabilities only 
for these parents configuration will be returned. If concrete values of node are given in array node then
only probabilities of these values will be returned. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's consider getting of probabilities for node "NodeB" from example for SetPTabular method. Some variants to get "NodeB"
probabilites are available:
</p>
<p class="example">
TokArr PNodeB = net.GetPTabular("NodeB");<br>
TokArr PNodeBTrue = net.GetPTabular("NodeB^true");<br>
TokArr PNodeBNodeATrue = net.GetPTabular("NodeB", "NodeA^true");<br>
TokArr PNodeBTrueNodeAFalse = net.GetPTabular("NodeB^true", "NodeA^false");
</P>
<p class="description">
Results of these calls:
</p>
<p class="example">
<table>
<tr>
  <td>PNodeB</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^false^NodeA^true^0.01 NodeB^true^NodeA^false^0.4 NodeB^false^NodeA^false^0.6"</td>
</tr>
<tr>
  <td>PNodeBTrue</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^true^NodeA^false^0.4"</td>
</tr>
<tr>
  <td>PNodeBNodeATrue</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^false^NodeA^true^0.01"</td>
</tr>
<tr>
  <td>PNodeBTrueNodeAFalse</td>
  <td>"NodeB^true^NodeA^false^0.4"</td>
</tr>
</table>
<HR>

<H3><A 
name=decl_GetPNLEvidence>GetPNLEvidence</A></H3>
<P class=Blurb> Returns a pointer to the evidence (object of pnl::CEvidence class)
</P>
<font class="interface">
pnl::CEvidence *GetPNLEvidence();
</font>
<H5>Discussion</H5>
<p class="description">The function creates an object of pnl::CEvidence class based on the evidence you set. Then the function returns a pointer to the object. You should delete this object yourself.
</p>
<HR>

<H3><A 
name=decl_Inference>Inference</A></H3>
<P class=Blurb> Returns a reference to the object of pnl::CInfEngine class which corresponds to the current BayesNet object 
</P>
<font class="interface">
pnl::CInfEngine &Inference(bool Recreate = false);
</font>
<H5>Arguments</H5>
<DL>
  <DT>Recreate
  <DD>If Recreate variable is equal to true then pnl::CInfEngine object is recreated and the function returns a reference to the new object.
</DL> 
<H5>Discussion</H5>
<p class="description">The object which the function returns is internal. We do not recommend you to use this method if don't really need it.
</p>
<HR>

<H3><A 
name=decl_Model>Model</A></H3>
<P class=Blurb> Returns a reference to the object of pnl::CBNet class which corresponds to the current BayesNet object 
</P>
<font class="interface">
pnl::CBNet &Model();
</font>
<H5>Discussion</H5>
<p class="description">The object which the function returns is internal. We do not recommend you to use this method if don't really need it.
</p>
<HR>

<H3><A 
name=decl_Learning>Learning</A></H3>
<P class=Blurb> Returns a reference to the object of pnl::CStaticLearningEngine class which corresponds to the current BayesNet object 
</P>
<font class="interface">
pnl::CStaticLearningEngine &Learning();
</font>
<H5>Discussion</H5>
<p class="description">The object which the function returns is internal. We do not recommend you to use this method if don't really need it.
</p>
<HR>

<H3><A 
name=decl_SetPGaussian>SetPGaussian</A></H3>
<P class=Blurb>Sets parameters for gaussian variate. 
</P>
<font class="interface">
void SetPGaussian(TokArr var, TokArr mean = TokArr(), TokArr variance = TokArr(), TokArr weight = TokArr(), TokArr tabParentValue = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>var
  <DD>Name of node which probability is setted. 
  <DT>mean
  <DD>Vector of means. 
  <DT>variance
  <DD>Matrix of variance (for one-dimensional variate it is only one number).
  <DT>weight
  <DD>Matrixes of weights. This parameter is needed only when the node has parents. For more details about matrixes of weights see User Guide, chapter "Multivariate Gaussian case"
  <DT>tabParentValue
  <DD>Values of all tabular parents (for cond. Gaussian case only).
</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets parameters for gaussian variate. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's set gaussian distribution for one - dimentional node without parents.
</p>
<p class="example">
net.SetPGaussian("x0", "1.0", "4.0");
</p>
<p class="description">
Let's set gaussian distribution for one - dimentional node with two parents.
</p>
<p class="example">
net.SetPGaussian("x2", "0.0", "2.0", "1.0 2.0");
</P>
<p class="description">
Let's set gaussian distribution for two - dimensional node without parents.
</p>
<p class="example">
net.SetPGaussian("x0", "1.0 2.5", "4.0 0.1 0.1 4.0");
</p>
<p class="description">
Let's set gaussian distribution for two - dimentional node with three two - dimensional parents. Three matrixes of weights are:
</p>
<p class="description">
<table>
<tr>
  <td>The first matrix</td>
  <td>1.0</td>
  <td>2.0</td>
  <td>The second</td>
  <td>5.0</td>
  <td>6.0</td>
  <td>The third</td>
  <td>9.0</td>
  <td>10.0</td>
</tr>
<tr>
  <td></td>
  <td>3.0</td>
  <td>4.0</td>
  <td></td>
  <td>7.0</td>
  <td>8.0</td>
  <td></td>
  <td>11.0</td>
  <td>12.0</td>
</tr>
</table>
<p class="example">
net.SetPGaussian("x2", "1.0 2.5", "4.0 0.1 0.1 4.0", "1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0");
</P>
<HR>

<H3><A 
name=decl_EditEvidence>EditEvidence</A></H3>
<P class=Blurb>Edits current evidence 
</P>
<font class="interface">
void EditEvidence(TokArr values);
</font>
<H5>Arguments</H5>
<DL>
  <DT>values
  <DD>Array of observed nodes with values.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets or edits current evidence. New observed nodes are added to current evidence
with EditEvidence method or old values of observed nodes are changed.
</p>
<H5>
Example of usage
</H5>
<p class="description">
</p>
<p class="example">
net.EditEvidence("NodeA^true NodeB^false");<br>
net.EditEvidence("NodeA^false NodeC^true");
</P>
<p class="description">
In current evidence there are three observed tabular nodes: "NodeA", "NodeB" (both are false) and "NodeC"(true).
</p>
<p class="example">
net.EditEvidence("ContNodeA^dim1^-15.0 ContNodeA^dim2^6.4");<br>
net.EditEvidence("ContNodeB^dim1^5.0");
</P>
<p class="description">
In current evidence there are two observed continuous nodes: "NodeA" (with 2 dimensions), "NodeB" (with one dimension).
</p>
<HR>

<H3><A 
name=decl_GetCurEvidenceLogLik>GetCurEvidenceLogLik</A></H3>
<P class=Blurb>Returns logarithm of likelihood for current evidence 
</P>
<font class="interface">
float GetCurEvidenceLogLik();
</font>
<H5>Discussion</H5>
<p class="description">The function returns logarithm of likelihood for current evidence.
</p>
<H5>
Example of usage
</H5>
<p class="description">
</p>
<p class="example">
net.EditEvidence("NodeA^true NodeB^false");<br>
float logLik = net.GetCurEvidenceLogLik();
</p>
<HR>

<H3><A 
name=decl_ClearEvid>ClearEvid</A></H3>
<P class=Blurb>Clears current evidence 
</P>
<font class="interface">
void ClearEvid();
</font>
<H5>Discussion</H5>
<p class="description">The function clears current evidence. 
</font>
<H5>
Example of usage
</H5>
<p class="example">
net.EditEvidence("NodeA^true NodeB^false");<br>
net.ClearEvid();
</P>
<p class="description">
Current evidence is empty now.
</p>
<HR>

<H3><A 
name=decl_CurEvidToBuf>CurEvidToBuf</A></H3>
<P class=Blurb>Stores current evidence to the evidence buffer 
</P>
<font class="interface">
void CurEvidToBuf();
</font>
<H5>Discussion</H5>
<p class="description">The function stores current evidence to the buffer of evedences. Current evidence is not cleared.
</font>
<H5>
Example of usage
</H5>
<p class="example">
net.EditEvidence("NodeA^true NodeB^false");<br>
net.EditEvidence("NodeA^false NodeC^true");<br>
net.CurEvidToBuf();<br>
net.EditEvidence("NodeB^true");<br>
net.CurEvidToBuf();
</P>
<p class="description">
In current evidence there are three observed nodes now: "NodeA" takes on value "false", "NodeB" and "NodeC" take on values "true".
</p>
<p class="description">
In evidence buffer there are two evidences now. In first evidence "NodeA" and "NodeB" take on values "false", and "NodeC" 
takes on value "true". In second one "NodeA" takes on value "false", "NodeB" and "NodeC" take on values "true".
</p>
<HR>

<H3><A 
name=decl_AddEvidToBuf>AddEvidToBuf</A></H3>
<P class=Blurb>Adds evidence to the evidence buffer 
</P>
<font class="interface">
void AddEvidToBuf(TokArr values);
</font>
<H5>Arguments</H5>
<DL>
  <DT>values
  <DD>Array of observed nodes with values.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds evidence to the buffer. Current evidence is not changed.
</font>
<H5>
Example of usage
</H5>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");
</P>
<p class="description">
In evidence buffer there are two evidences now. In first evidence "NodeA" takes on value "true" and "NodeB" takes on value "false".
In second one "NodeA" takes on value "false" and "NodeC" takes on value "true".
</p>
<p class="example">
net.AddEvidToBuf("ContNodeA^dim1^-15.0 ContNodeA^dim2^6.4");<br>
net.AddEvidToBuf("ContNodeB^dim1^5.0");
</P>
<p class="description">
There are two evidences for continuous nodes: "NodeA" (with 2 dimensions) and "NodeB" (with one dimension) in the last example which we add to the buffer.
</p>
<HR>

<H3><A 
name=decl_GetEvidBufLogLik>GetEvidBufLogLik</A></H3>
<P class=Blurb>Returns array of logarithms of likelihood for evidences from buffer
</P>
<font class="interface">
TokArr GetEvidBufLogLik();
</font>
<H5>Discussion</H5>
<p class="description">The function returns array of logarithms of likelihood for evidences from buffer.
</font>
<H5>
Example of usage
</H5>
<p class="description">
Let's generate evidences, put them to buffer and find the sum of theif
logarifmic likelihood.
</p>
<pre>&nbsp;</pre>
<p class="example">
net.GenerateEvidences(1000);&nbsp;
</p>
<p class="example">
TokArr bufLogLiks = net.GetEvidBufLogLik();&nbsp;
</p>
<p class="example">
float logLikBest = 0.0f;&nbsp;
</p>
<p class="example">
for(int i = 0; i < 1000; i++)&nbsp;
</p>
<p class="example">
{&nbsp;
</p>
<p class="example">
&nbsp;&nbsp;&nbsp; logLikBest += bufLogLiks[i].FltValue();&nbsp;
</p>
<p class="example">
}
</p>
<HR>

<H3><A 
name=decl_ClearEvidBuf>ClearEvidBuf</A></H3>
<P class=Blurb>Clears evidence buffer 
</P>
<font class="interface">
void ClearEvidBuf();
</font>
<H5>Arguments</H5>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">The function clears evidence buffer. 
</font>
<H5>
Example of usage
</H5>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.ClearEvidBuf();
</P>
<p class="description">
Evidence buffer is empty now.
</p>
<HR>

<H3><A 
name=decl_MaskEvidBuf>MaskEvidBuf</A></H3>
<P class=Blurb>Hides nodes of current learning buffer with given probability 
</P>
<font class="interface">
void MaskEvidBuf(TokArr whatNodes = "");
</font>
<H5>Arguments</H5>
<DL>
  <DT>whatNodes
  <DD>Array of nodes.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function hides nodes of current learning buffer with given probability. The function applies for all existing 
values (hidden and observed), i.e. observed may become hidden and hidden may become observed. By default this function 
unhides all hidden values. If a node did not have sample then it can not be unhidden.
</font>
<H5>
Example of usage
</H5>
<p class="example">
</P>
<HR>

<H3><A 
name=decl_LearnParameters>LearnParameters</A></H3>
<P class=Blurb>Learns network parameters 
</P>
<font class="interface">
void LearnParameters(TokArr aValue[] = NULL, int nValue = 0);
</font>
<H5>Arguments</H5>
<DL>
  <DT>aValue
  <DD>Array of evidences. Each evidence is array of observed nodes with values. 
  <DT>nValue
  <DD>Number of evidences.</DD></DL>
<H5>Discussion</H5>
<p class="description">
The function learns network parameters using evidence buffer. If function with parameters is called then new 
evidences are added to evidence buffer then learning is started up. Learning algorithm may be set to property "Learning" with 
method <A href="#decl_SetProperty">SetProperty()</A>. By default EM learning is used. Besides Bayes learning is available.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Folowing three code pieces are equal:
</p>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.LearnParameters();
</P>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
TokArr evidences[] = {"NodeA^false NodeC^true"};<br>
net.LearnParameters(evidences);
</P>
<p class="example">
TokArr evidences[] = {"NodeA^true NodeB^false", "NodeA^false NodeC^true"};<br>
net.LearnParameters(evidences);
</P>
<HR>

<H3><A 
name=decl_GetEMLearningCriterionValue>GetEMLearningCriterionValue</A></H3>
<P class=Blurb>Returns criterion value for last EM learning execution 
</P>
<font class="interface">
float GetEMLearningCriterionValue();
</font>
<H5>Discussion</H5>
<p class="description">
The function returns criterion value that was got during last EM learning
execution.
</p>
<H5>
Example of usage
</H5>
<p class="example">
net.SetProperty("Learning", "em");<br>
net.LearnParameters();<br>
float resLogLik = net.GetEMLearningCriterionValue();
</P>
<HR>

<H3><A 
name=decl_LearnStructure>LearnStructure</A></H3>
<P class=Blurb>Learns structure of the network 
</P>
<font class="interface">
void LearnStructure(TokArr aValue[], int nValue);
</font>
<H5>Arguments</H5>
<DL>
  <DT>aValue
  <DD>Array of evidences. Each evidence is array of observed nodes with values. 
  <DT>nValue
  <DD>Number of evidences.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function learns structure of the network using evidence buffer. If function with parameters is called then new 
evidences are added to evidence buffer then learning is started up. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Folowing three code pieces are equal:
</p>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.LearnStructure();
</P>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
TokArr evidences[] = {"NodeA^false NodeC^true"};<br>
net.LearnStructure(evidences);
</P>
<p class="example">
TokArr evidences[] = {"NodeA^true NodeB^false", "NodeA^false NodeC^true"};<br>
net.LearnStructure(evidences);
</P>
<HR>

<H3><A 
name=decl_GetMPE>GetMPE</A></H3>
<P class=Blurb>Returns MPE 
</P>
<font class="interface">
TokArr GetMPE(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes from one family.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns most probable explanation (MPE) for specified nodes using current evidence. The inference algorithm
may be set to property "Inference" with method <A href="#decl_SetProperty">SetProperty()</A>. By default Pearl inference is used. Besides Gibbs sampling,
Junction Tree inference and Naive inference are available. Corresponding property "Inference" values are "pearl", "gibbs",
"jtree", "naive".
</font>
<H5>
Example of usage
</H5>
<p class="description">
Get MPE for node "NodeA" with Junction Tree inference:
</p>
<p class="example">
net.SetProperty("Inference", "jtree");<br>
TokArr jtreeMPENodeA = net.GetMPE("NodeA");
</P>
<p class="description">
Get MPE for nodes "NodeA" and "NodeB" with Pearl inference (nodes "NodeA" and "NodeB" must be from the same family):
</p>
<p class="example">
net.SetProperty("Inference", "pearl");<br>
TokArr pearlMPENodeA = net.GetMPE("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_GetJPD>GetJPD</A></H3>
<P class=Blurb>Returns JPD 
</P>
<font class="interface">
TokArr GetJPD(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes from one family.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns joint probability distribution (JPD) for specified nodes using current evidence. The inference algorithm
may be set to property "Inference" with method <A href="#decl_SetProperty">SetProperty()</A>. By default Pearl inference is used. Besides Gibbs sampling,
Junction Tree inference and Naive inference are available. Corresponding property "Inference" values are "pearl", "gibbs",
"jtree", "naive".
</font>
<H5>
Example of usage
</H5>
<p class="description">
Get JPD for node "NodeA" with Junction Tree inference:
</p>
<p class="example">
net.SetProperty("Inference", "jtree");<br>
TokArr jtreeJPDNodeA = net.GetJPD("NodeA");
</P>
<p class="description">
Get JPD for nodes "NodeA" and "NodeB" with Pearl inference (nodes "NodeA" and "NodeB" must be from the same family):
</p>
<p class="example">
net.SetProperty("Inference", "pearl");<br>
TokArr pearlJPDNodeA = net.GetJPD("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_SetProperty>SetProperty</A></H3>
<P class=Blurb>Sets value to the property
</P>
<font class="interface">
void SetProperty(const char *name, const char *value);
</font>
<H5>Arguments</H5>
<DL>
  <DT>name
  <DD>Name of property. 
  <DT>value
  <DD>Value of property.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets value to the property with given name. The function is used to specify algorithms
for learning and getting MPE and JPD and to specify parameters of algorithms. User can use this function to define his own
properties. Used properties names with their possible values and descriptions are presented in table:
</p>
<table width="100%">
<tr><td width="50pt" Rowspan="10"></td>
<td><table BORDER="1">
  <tr>
     <td width="20%"><center><b>Property Name</b></center></td>
     <td width="25%"><center><b>Possible Values</b></center></td>
     <td width="55%"><center><b>Description</b></center></td>
  </tr>
  <tr>
     <td>"Learning"</td>
     <td>"bayes", "em"</td>
     <td>Algorithm for parameters learning. EM Learning is used by default.</td>
  </tr>
  <tr>
     <td>"EMMaxNumberOfIterations"</td>
     <td>Any positive integer number</td>
     <td>Maximum number of iterations of EM Learning algorithm. Default value is 5.</td>
  </tr>
  <tr>
     <td>"EMTolerance"</td>
     <td>Any positive float number</td>
     <td>Precision that  EM Learning algorithm runs up to. Default value is 0.001.</td>
  </tr>
  <tr>
     <td>"Inference"</td>
     <td>"pearl", "jtree", "gibbs", "naive"</td>
     <td>Inference algorithm that is used for getting MPE and JPD. Pearl Inference is used by default.</td>
  </tr>
  <tr>
     <td>"PearlMaxNumberOfIterations"</td>
     <td>Any positive integer number</td>
     <td>Maximum number of iterations of Pearl Inference algorithm. Default value is equal to number of nodes of net.</td>
  </tr>
  <tr>
     <td>"PearlTolerance"</td>
     <td>Any positive float number</td>
     <td>Precision that Pearl Inference algorithm runs up to. Default value is 1e-6.</td>
  </tr>
  <tr>
     <td>"GibbsNumberOfIterations"</td>
     <td>Any positive integer number</td>
     <td>Number of iterations of Gibbs Sampling Inference algorithm. Default value is 600.</td>
  </tr>
  <tr>
     <td>"GibbsThresholdIteration"</td>
     <td>Any positive integer number less than GibbsNumberOfIterations value</td>
     <td>Number of first itearation that use samples processing results of the previous iteration. Default value is 10.</td>
  </tr>
  <tr>
     <td>"GibbsNumberOfStreams"</td>
     <td>Any positive integer number</td>
     <td>Number of streams that generate independent samples. Default value is 1.</td>
  </tr>
  <tr>
     <td>"LearningStructureMethod"</td>
     <td>"MaxLh","PreAs", "MarLh"</td>
     <td>Score method for structure learning. Default value is MaxLh.</td>
  </tr>
  <tr>
     <td>"LearningStructureScoreFun"</td>
     <td>"BIC","AIC","WithoutPenalty"</td>
     <td>Score function for structure learning. Default value is BIC.</td>
  </tr>
  <tr>
     <td>"LearningStructurePrior"</td>
     <td>"Dirichlet","K2","BDeu"</td>
     <td>Prior`s type that is used with Marlh(BDe metric) score method. Default value is Dirichlet.</td>
  </tr>
  <tr>
     <td>"LearningStructureK2PriorVal"</td>
     <td>Any positive integer number</td>
     <td>Inital K2 prior value. Default value is 0.</td>
  </tr>			
</table><tr></td>
</table>
<H5>
Example of usage
</H5>
<p class="description">
Set Pearl inference for getting MPE and JPD:
</p>
<p class="example">
net.SetProperty("Inference", "pearl");
</P>
<p class="description">
Set maximum of iterations for Pearl inference:
</p>
<p class="example">
net.SetProperty("PearlMaxNumberOfIterations", "50");
</P>
<p class="description">
Set Bayessian learning as algorithm for parameters learning:
</p>
<p class="example">
net.SetProperty("Learning", "em");
</P>
<p class="description">
Any other property can be defined by user:
</p>
<p class="example">
net.SetProperty("IterationsNumber", "100");
</P>
<HR>

<H3><A 
name=decl_GetProperty>GetProperty</A></H3>
<P class=Blurb>Returns value of the property with given name
</P>
<font class="interface">
String GetProperty(const char *name) const;
</font>
<H5>Arguments</H5>
<DL>
  <DT>name
  <DD>Name of property.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns value of the property with given name. If property was not set with 
<A href="#decl_SetProperty">SetProperty</A> method then empty string is returned.
</p>
<H5>
Example of usage
</H5>
<p class="example">
net.SetProperty("Inference", "pearl");<br>
String inferenceType = net.GetProperty("Inference");<br>
String learningType = net.GetProperty("Learning");
</P>
<p class="description">
As result string inferenceType is "pearl" and string learningType is empty.
</p>
<HR>

<H3><A 
name=decl_GetGaussianMean>GetGaussianMean</A></H3>
<P class=Blurb>Returns mean of gaussian distribution 
</P>
<font class="interface">
TokArr GetGaussianMean(TokArr node, TokArr tabParentValue = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>node
  <DD>Name of node whose mean is needed
  <DT>tabParentValue
  <DD>Values of all tabular parents (for cond. Gaussian case only)
</DL>
<H5>Discussion</H5>
<p class="description">The function returns mean of gaussian distribution. 
</p>
<H5>
Example of usage
</H5>
<p class="example">
TokArr MeanX2 = net.GetGaussianMean("x2");
</p>

<HR>

<H3><A 
name=decl_GetGaussianCovar>GetGaussianCovar</A></H3>
<P class=Blurb>Returns variance of gaussian distribution 
</P>
<font class="interface">
TokArr GetGaussianCovar(TokArr node, TokArr tabParentValue = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>node
  <DD>Name of node whose variance is needed
  <DT>tabParentValue
  <DD>Values of all tabular parents (for cond. Gaussian case only)
</DL>
<H5>Discussion</H5>
<p class="description">The function returns variance of gaussian distribution. 
</p>
<H5>
Example of usage
</H5>
<p class="example">
TokArr CovarX2 = net.GetGaussianCovar("x2");
</P>
<HR>

<H3><A 
name=decl_GetGaussianWeights>GetGaussianWeights</A></H3>
<P class=Blurb>Returns weights of gaussian distribution. 
</P>
<font class="interface">
TokArr GetGaussianWeights(TokArr node, TokArr parent, TokArr tabParentValue = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>node
  <DD>Name of node whose weights are needed. 
  <DT>parent
  <DD>A parent of node which weights we are interested in. 
  <DT>tabParentValue
  <DD>Values of all tabular parents (for cond. Gaussian case only)
</DL>
<H5>Discussion</H5>
<p class="description">The function returns weights of parent of specified node . 
</p>
<H5>
Example of usage
</H5>
<p class="example">
TokArr WeightsYX2 = net.GetGaussianWeights("y", "x2");
</P>
<HR>

<H3><A 
name=decl_SaveNet>SaveNet</A></H3>
<P class=Blurb>Saves network to file 
</P>
<font class="interface">
void SaveNet(const char *filename);
</font>
<P>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name.</DD></DL>
<H5>Discussion</H5>
<p class="description">
The function saves network to file of "xml" format with given name. Net structure and nodes distributions 
of probabilities are stored to file.
</p>
<H5>
Example of usage
</H5>
<p class="example">
net.SaveNet("net.xml");
</P>
<HR>

<H3><A 
name=decl_SaveEvidBuf>SaveEvidBuf</A></H3>
<P class=Blurb>Saves evidence buffer content to file 
</P>
<font class="interface">
int SaveEvidBuf(const char *filename, NetConst::ESavingType mode = NetConst::eCSV);
</font>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name. 
  <DT>mode
  <DD>This parameter specifies separating character. Two separating characters are available: ',' (if mode is set to eCSV)
and tab (if mode is set to eTSV).</DD></DL>
<H5>Discussion</H5>
<p class="description">The function saves evidence buffer content to file of "cvs" format. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Save two evidences to file with ',' separator:
</p>
<p class="example">
net.ClearEvidBuf();<br>
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.SaveEvidBuf("evidence1.csv");
</P>
<p class="description">
Save the same two evidences to file with tab separator:
</p>
<p class="example">
net.ClearEvidBuf();<br>
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.SaveEvidBuf("evidence2.csv", NetConst::eTSV);
</P>
<HR>

<H3><A 
name=decl_LoadNet>LoadNet</A></H3>
<P class=Blurb>Loads network from file 
</P>
<font class="interface">
void LoadNet(const char *filename);
</font>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function loads network from file with given name. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Load net structure and distributions from file "net.xml":
</p>
<p class="example">
net.LoadNet("net.xml");
</P>
<HR>

<H3><A 
name=decl_LoadEvidBuf>LoadEvidBuf</A></H3>
<P class=Blurb>Loads evidence buffer content from file 
</P>
<pre>
<font class="interface">
int LoadEvidBuf(const char *filename, 
                NetConst::ESavingType mode = NetConst::eCSV, 
                TokArr columns = TokArr());
</font>
</pre>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name. 
  <DT>mode
  <DD>Separating character used in file is passed in this parameter. Two separating characters are available: 
',' (if mode is set to eCSV) and tab (if mode is set to eTSV). 
  <DT>columns
  <DD>Names of nodes.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function loads evidence buffer content from file. Buffer is cleared before loading. We can load evidences created in
another net with another node names but with the same values of nodes. For this we must set new node names in evidences 
using array "columns". The function returns number of evidences loaded from file.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Load evidences from file "evidence1.csv" with ',' separators and perform learning with them:
</p>
<p class="example">
net.LoadEvidBuf("evidence1.csv");<br>
net.LearnParameters();
</P>
<HR>
<!--
<H3><A 
name=decl_MakeUniformDistribution>MakeUniformDistribution</A></H3>
<P class=Blurb>Sets uniform distribution on all nodes 
</P>
<font class="interface">
void MakeUniformDistribution();
</font>
<H5>Arguments</H5>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">The function .... 
</font>
<H5>
Example of usage
</H5>
<p class="example">
</P>
<HR>
-->
<H3><A 
name=decl_GenerateEvidences>GenerateEvidences</A></H3>
<P class=Blurb>Generate samples for the network 
</P>
<font class="interface">
void GenerateEvidences( int nSamples, bool ignoreCurrEvid = false, TokArr whatNodes = "");
</font>
<H5>Arguments</H5>
<DL>
  <DT>nSamples
  <DD>Number of samples to generate. 
  <DT>ignoreCurrEvid 
  <DD>Flag of current evidence ignorance. If true - the current evidence will be ignored. Default value is false.  
  <DT>whatNodes 
  <DD>Array of names of variables to generate and portion of observed data. Default empty array means that all samples will be generated. </DD>
</DL>
<H5>Discussion</H5>
<p class="description">The function generates the specified number of samples from joint probability distribution of the network.
Samples may be generated using the current evidence (set by <A href="#decl_EditEvidence">EditEvidence</A> function)
 or ignoring the current evidence. The function allows generating samples with specified portion of missing variables.
If current evidence is taken into account (ignoreCurrEvid == true) then sampled values of nodes present in evidence
will be equal to values of current evidence. 
The sampled data can be generated so that there will be some portion of missing values - for every node user may specify the portion of 
non-missing values in the generated array.  
The newly generated samples will be added to internal buffer (learning buffer). To clear learning buffer use <A href="#decl_ClearEvidBuf">ClearEvidBuf</A>. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Generate 100 samples for all network nodes ignoring current evidence: 
</p>
<p class="example">
GenerateEvidences( 100, true);
</P>
<p class="description">
Generate 100 samples only for nodes "NodeA","NodeB" and "NodeC" using current evidence:
</p>
<p class="example">
TokArr whatNodesToSample = TokArr("NodeA") & "NodeB" & "NodeC";<br>
GenerateEvidences(100, false, whatNodesToSample);
</P>
<p class="description">
Generate 100 samples only for nodes "NodeA","NodeB" and "NodeC" using current evidence. "NodeA" should contain 90% of observed values, "NodeB" and "NodeC" should contain 100% of observed data:
</p>
<p class="example">
    TokArr whatNodesToSample = Tok("NodeA")^0.9 & "NodeB" & Tok("NodeC")^1.0;<br>
    GenerateEvidences( 100, false, whatNodesToSample);
</P>
<p class="description">
Generate 100 samples for nodes "NodeA","NodeB" and "NodeC" using current evidence. All nodes should contain 90% of observed values:
</p>
<p class="example">
    TokArr whatNodesToSample = (Tok("NodeA") "NodeB" & Tok("NodeC") ) ^ 0.9;<br>
    GenerateEvidences( 100, false, whatNodesToSample);
</P>
<p class="description">
Generate 100 samples for all nodes using current evidence. All nodes should contain 90% of observed values:
</p>
<p class="example">
    TokArr whatNodesToSample = 0.9;<br>
    GenerateEvidences( 100, false, whatNodesToSample);
</P>

<HR>

<H2><A name=decl_Class_DBN>Class DBN</A></H2>
<HR>

<P>Class DBN implements all functionality required for work with dynamic bayesian networks. 
The following functional groups can be distinguished:
<UL>
    <LI>Network creation (addition/deletion of nodes and arcs)<BR>
    <A href="#decl_AddNode_DBN">AddNode</A>,
    <A href="#decl_DelNode_DBN">DelNode</A>,
    <A href="#decl_AddArc_DBN">AddArc</A>,
    <A href="#decl_DelArc_DBN">DelArc</A>.
    </LI>
    <LI>Setting/getting parameters<BR>
    <A href="#decl_SetPTabular_DBN">SetPTabular</A>,
    <A href="#decl_GetPTabular_DBN">GetPTabular</A>,
    <A href="#decl_SetPGaussian_DBN">SetPGaussian</A>,
    <A href="#decl_GetGaussianMean_DBN">GetGaussianMean</A> ,
    <A href="#decl_GetGaussianCovar_DBN">GetGaussianCovar</A>,
    <A href="#decl_EditEvidence_DBN">EditEvidence</A>,
    <A href="#decl_ClearEvid_DBN">ClearEvid</A>,
    <A href="#decl_CurEvidToBuf_DBN">CurEvidToBuf</A>,
    <A href="#decl_AddEvidToBuf_DBN">AddEvidToBuf</A>,
    <A href="#decl_ClearEvidBuf_DBN">ClearEvidBuf</A>,
    <A href="#decl_GetChildren_DBN">GetChildren</A>,
    <A href="#decl_GetParents_DBN">GetParents</A>,
    <A href="#decl_GetNeighbours_DBN">GetNeighbours</A>,
    <A href="#decl_SetProperty_DBN">SetProperty</A>,
    <A href="#decl_GetProperty_DBN">GetProperty</A>,
    <A href="#decl_SetNumSlices_DBN">SetNumSlices</A>,
    <A href="#decl_Unroll_DBN">Unroll</A>,
    <A href="#decl_Inference_DBN">Inference</A>,
    <A href="#decl_Learning_DBN">Learning</A>,
    <A href="#decl_Model_DBN">Model</A>, 
    <A href="#decl_GetPNLEvidences_DBN">GetPNLEvidences</A>
   
    <LI>Learning parameters<BR>
    <A href="#decl_LearnParameters_DBN">LearnParameters</A>
    </LI>
    <LI>Inference in network<BR>
    <A href="#decl_GetJPD_DBN">GetJPD</A>,
    <A href="#decl_GetMPE_DBN">GetMPE</A>
    </LI>
    <LI>Data sampling<BR>
    <A href="#decl_GenerateEvidences_DBN">GenerateEvidences</A>
    </LI>
    <LI>File I/O<BR>
    <A href="#decl_LoadNet_DBN">LoadNet</A>,
    <A href="#decl_SaveNet_DBN">SaveNet</A>,
    <A href="#decl_LoadEvidBuf_DBN">LoadEvidBuf</A>,
    <A href="#decl_SaveEvidBuf_DBN">SaveEvidBuf</A>
    </LI>
    <LI>more...</LI>
</UL>
<HR>


<H3><A name=decl_DBN>DBN</A></H3>
<P class=Blurb>Constructor</P>
<font class="interface">
DBN();
</font>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">DBN class has only default constructor.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Create empty dynamic bayessian net:
</p>
<p class="example">
DBN dbn;
</p>
<HR>

<H3><A name=decl_AddNode_DBN>AddNode</A></H3>
<P class=Blurb>Adds nodes</P>
<font class="interface">
void AddNode(TokArr nodes, TokArr subnodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>List of nodes with nodes type (discrete or continuous) specifying. 
  <DT>subnodes
  <DD>Array of values that nodes can take (or names of dimensions for continuous nodes). 
</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds one or several nodes with the same probable states into the network. We adds only 
0 and 1 slices nodes. Node names must consists of "name-slice number". 0 slice nodes adds before 1 slice nodes.</p>
<H5>
Example of usage
</H5>
<p class="description">
Add one discrete node "Street-0"  with states "true" and "false" to dynamic bayessian net:
</p>
<p class="example">
dbn.AddNode(discrete^"Street-0", "true false");
</p>
<p class="description">
Add one-dimensional continuous node "Street-0" to dynamic bayessian net:
</p>
<p class="example">
dbn.AddNode(continuous^"Street-0", "dim1");
</p>
<p class="description">
Add discrete nodes "Street-0" and "House-0" with states "true" and "false" to dynamic bayessian net:
</p>
<p class="example">
dbn.AddNode(discrete^"Street-0 House-0", "true false");
</p>
<HR>

<H3><A name=decl_DelNode_DBN>DelNode</A></H3>
<P class=Blurb>Deletes nodes</P>
<font class="interface">
void DelNode(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of names of nodes to delete. 
  </DD></DL>
<H5>Discussion</H5>
<p class="description">The function deletes one or several nodes from network together with all adjacent edges. 
You may delete node with name "NodeA" from any slice and it corresponds deleting nodes "NodeA" from all slices.    
</p>
<H5>
Example of usage
</H5>
<p class="description">
Delete nodes "NodeA-4" and "NodeB-3":
</p>
<p class="example">
dbn.DelNode("NodeA-4 NodeB-3");
</P>
<HR>

<H3><A name=decl_GetNodeType_DBN>GetNodeType</A></H3>
<P class=Blurb>Returns types of the given nodes</P>
<font class="interface">
TokArr GetNodeType(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes whose type is interesting. 
</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns array of types (discrete or continuous) of given nodes.
Nodes from 0 and 1 slice must be used only because node type in any i-th slice (i > 1) are the same.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get array of types of nodes "NodeA-0" and "NodeB-1":
</p>
<p class="example">
   TokArr nodeTypes = dbn.GetNodeType("NodeA-0 NodeB-1");
</P>
<HR>

<H3><A name=decl_AddArc_DBN>AddArc</A></H3>
<P class=Blurb>Adds arc</P>
<font class="interface">
void AddArc(TokArr from, TokArr to);
</font>
<H5>Arguments</H5>
<DL>
  <DT>from
  <DD>Array of starting nodes of the arcs. 
  <DT>to
  <DD>Array of ending nodes of the arcs</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds one or several arcs to the network. Each starting node is connected with each ending node.
Starting  and endind nodes arrays consists only of nodes 0 and 1 slices, because for any i-th slice (i > 0) arcs adds automaticly.   
</p>
<H5>
Example of usage
</H5>
<p class="description">
Add edge from node "NodeA-0"  to node "NodeB-1":
</p>
<p class="example">
dbn.AddArc("NodeA-0", "NodeB-1");
</P>
<p class="description">
Add two edges: from "NodeA-0" to "NodeB-1" and from "NodeA-0" to "NodeC-0":
</p>
<p class="example">
dbn.AddArc("NodeA-0", "NodeB-1 NodeC-0");
</P>
<p class="description">
Add four edges: from "NodeA-0" to "NodeC-0", from "NodeA-0"  to "NodeD-1", from "NodeB-0" to "NodeC-0" and from "NodeB-0" to "NodeD-1":
</p>
<p class="example">
dbn.AddArc("NodeA-0 NodeB-0", "NodeC-0 NodeD-1");
</P>
<HR>

<H3><A name=decl_DelArc_DBN>DelArc</A></H3>
<P class=Blurb>Deletes arcs</P>
<font class="interface">
void DelArc(TokArr from, TokArr to);
</font>
<H5>Arguments</H5>
<DL>
  <DT>from
  <DD>Array of starting nodes of the arcs to delete. 
  <DT>to
  <DD>Array of ending nodes of the arcs to delete. 
  </DD></DL>
<H5>Discussion</H5>
<p class="description">The function deletes one or several arcs from the network. 
Starting  and endind nodes arrays consists only of nodes 0 and 1 slices, because for any i-th slice (i > 0) deletes adds automaticly.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Delete edge from node "NodeA-1" to node "NodeB-1" :
</p>
<p class="example">
dbn.DelArc("NodeA-1", "NodeB-1");
</P>
<p class="description">
Delete following two edges if they exist: from "NodeA-0" to "NodeB-1" and from "NodeA-0") to "NodeC-0":
</p>
<p class="example">
dbn.DelArc("NodeA-0", "NodeB-1 NodeC-0");
</P>
<p class="description">
Delete all edges with starting node "NodeA-0" or "NodeB-0" and ending node "NodeC-0" or "NodeD-1":
</p>
<p class="example">
dbn.DelArc("NodeA-0 NodeB-0", "NodeC-0 NodeD-1");
</P>
<HR>

<H3><A 
name=decl_GetNeighbours_DBN>GetNeighbours</A></H3>
<P class=Blurb>Returns list of neighbours for given node 
</P>
<font class="interface">
TokArr GetNeighbours(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>One or several nodes whose neighbours are need.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns list of neighbours for given node or some nodes. If neighbours of several nodes are demanded then neighbors of every node are in the result, each neighbor is once to be found in list.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get neighbors of node "NodeA-3":
</p>
<p class="example">
TokArr NodeANeighbors = dbn.GetNeighbours("NodeA-3");
</P>
<p class="description">
Get neighbors of node "NodeA-0" and neighbors of node "NodeB-1". If node "NodeC-1" is neighbor both "NodeA-0" and "NodeB-1" then it is once to be found in result list of neighbors:
</p>
<p class="example">
TokArr NodeAandBNeighbors = dbn.GetNeighbours("NodeA-0 NodeB-1");
</P>
<HR>

<H3><A 
name=decl_GetParents_DBN>GetParents</A></H3>
<P class=Blurb>Returns list of parents for given node 
</P>
<font class="interface">
TokArr GetParents(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>One or several nodes whose parents are need.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns list of parents for given node or some nodes. If parents of several nodes are demanded then parents of every node are in the result, each parent is once to be found in result list.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get parents of node "NodeA-2":
</p>
<p class="example">
TokArr NodeAParents = dbn.GetParents("NodeA-2");
</P>
<p class="description">
Get parents of node "NodeA-1" and parents of node "NodeB-2". If node "NodeC-1" is parent both "NodeA-1" and "NodeB-2" then it is once to be found in result list of parents:
</p>
<p class="example">
TokArr NodeAandBParents = dbn.GetParents("NodeA-1 NodeB-2");
</P>
<HR>

<H3><A 
name=decl_GetChildren_DBN>GetChildren</A></H3>
<P class=Blurb>Returns list of children for given node 
</P>
<font class="interface">
TokArr GetChildren(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>One or several nodes whose children are need.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns list of children for given node or some nodes.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Get children of node "NodeA"(slice 0) :
</p>
<p class="example">
TokArr NodeAChildren = dbn.GetChildren("NodeA-0");
</P>
<p class="description">
Get children of node "NodeA-0" and children of node "NodeB-0". If node "NodeC-0" is child both "NodeA-0" and "NodeB-0" then it is once to be found in result list of children:
</p>
<p class="example">
TokArr NodeAandBChildren = dbn.GetChildren("NodeA-0 NodeB-0");
</P>
<HR>

<H3><A 
name=decl_GetNumSlices_DBN>GetNumSlices</A></H3>
<P class=Blurb>Returnes number of slices in the network
</P>
<font class="interface">
int GetNumSlives();
</font>
<H5>Discussion</H5>
<p class="description">The function returnes number of network slices. 
</p>
<HR>

<H3><A 
name=decl_SetNumSlices_DBN>SetNumSlices</A></H3>
<P class=Blurb>Sets number of slices in the network
</P>
<font class="interface">
void SetNumSlices(int nSlives);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nSlices
  <DD>Number of network slices.</DD> 
</DL>
<H5>Discussion</H5>
<p class="description">The function sets number of network slices. 
</font>
<H5>
Example of usage
</H5>
<p class="description">
Setting 5 slices :
</p>
<p class="example">
dbn.SetNumSlices(5);
</P>
<HR>

<H3><A 
name=decl_SetPTabular_DBN>SetPTabular</A></H3>
<P class=Blurb>Assigns probability to one or several values of one discrete node 
</P>
<font class="interface">
void SetPTabular(TokArr value, TokArr prob, TokArr parentValue = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>value
  <DD>Array of node values for wich probabilities are set. 
  <DT>prob
  <DD>Array of values of probabilities.
  <DT>parentValue
  <DD>Array of values of discrete parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets [conditional] probability for one or several values of the discrete node 
[for given values of parents]. Sizes of values array and probabilities array must be the same. While distribution 
of probabilities is not specified it is considered uniform. We can set distribution only on 0 and 1 slices nodes, 
because on any i-th slices (i > 0) nodes distributions are the same. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let`s node "NodeA-0" has not parents and can take on two values: "true" and "false". Its distribution of probabilities is unconditional. 
</p>
<p class="example">
dbn.SetPTabular("NodeA-0^true NodeA-0^false", "0.7 0.3");
</P>
<p class="description">
Let`s node "NodeB-1" can take on values "true" and "false" too and has only one parent "NodeA-0". Distribution of 
probabilities of "NodeB-1" is conditional. It is necessary to call SetPTabular method for each configuration of 
parents values:  
</p>
<p class="example">
dbn.SetPTabular("NodeB-1^true NodeB-1^false", "0.99 0.01", "NodeA-0^true");<br>
dbn.SetPTabular("NodeB-1^true NodeB-1^false", "0.4 0.6", "NodeA-0^false");
</P>
<HR>

<H3><A 
name=decl_GetPTabular_DBN>GetPTabular</A></H3>
<P class=Blurb>Returns probability of discrete node 
</P>
<font class="interface">
TokArr GetPTabular(TokArr node, TokArr parents = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>node
  <DD>Name of node or array of node values whose probabiliteis are needed. 
  <DT>parents
  <DD>Values of parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns probability of discrete node. If values of parents are given then probabilites only 
for these parents configurations will be returned. If concrete values of node are given in array node then
only probabilities of these values will be returned. We can get distribution only on 0 and 1 slices nodes. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let`s consider getting probabilities for node "NodeB-1" from example for SetPTabular method. Some variants to get "NodeB-1"
probabilites are available:
</p>
<p class="example">
TokArr PNodeB = dbn.GetPTabular("NodeB-1");<br>
TokArr PNodeBTrue = dbn.GetPTabular("NodeB-1^true");<br>
TokArr PNodeBNodeATrue = dbn.GetPTabular("NodeB-1", "NodeA-0^true");<br>
TokArr PNodeBTrueNodeAFalse = dbn.GetPTabular("NodeB-1^true", "NodeA-0^false");
</P>
<p class="description">
Results of these calls:
</p>
<p class="example">
<table>
<tr>
  <td>PNodeB</td>
  <td>"NodeB-1^true^NodeA-0^true^0.99 NodeB-1^false^NodeA-0^true^0.01 NodeB-1^true^NodeA-0^false^0.4 NodeB-0^false^NodeA-1^false^0.6"</td>
</tr>
<tr>
  <td>PNodeBTrue</td>
  <td>"NodeB-1^true^NodeA-0^true^0.99 NodeB-1^true^NodeA-0^false^0.4"</td>
</tr>
<tr>
  <td>PNodeBNodeATrue</td>
  <td>"NodeB-1^true^NodeA-0^true^0.99 NodeB-1^false^NodeA-0^true^0.01"</td>
</tr>
<tr>
  <td>PNodeBTrueNodeAFalse</td>
  <td>"NodeB-1^true^NodeA-0^false^0.4"</td>
</tr>
</table>
<HR>


<H3><A 
name=decl_GetPNLEvidences_DBN>GetPNLEvidences</A></H3>
<P class=Blurb>Returns a pointer to the vector of vectors of evidences (this function returns all evidences from buffer for every slices) .
</P>
<font class="interface">
pnl::pEvidencesVecVector GetPNLEvidences();
</font>
<H5>Di scussion</H5>
<p class="description">The function creates a vector of evidences and returns a pointer to the object. You should delete this object yourself.  
</p>
<HR>

<H3><A 
name=decl_Inference_DBN>Inference</A></H3>
<P class=Blurb>Returns a reference to the object of pnl::CDynamicInfEngine class which corresponds to the current DBN object  
</P>
<font class="interface">
pnl::CDynamicInfEngine &Inference();
</font>
<H5>Discussion</H5>
<p class="description">The object which the function returns is internal. We do not recommend you to use this method if don't really need it. 
</p>
<HR>

<H3><A 
name=decl_Learning_DBN>Learning</A></H3>
<P class=Blurb>Returns a reference to the object of pnl::CDynamicLearningEngine class which corresponds to the current DBN object 
</P>
<font class="interface">
pnl::CDynamicLearningEngine &Learning();
</font>
<H5>Discussion</H5>
<p class="description">The object which the function returns is internal. We do not recommend you to use this method if don't really need it. 
</p>
<HR>

<H3><A 
name=decl_Model_DBN>Model</A></H3>
<P class=Blurb>Returns a reference to the object of pnl::CDBN class which corresponds to the current DBN object 
</P>
<font class="interface">
pnl::CDBN &Model();
</font>
<H5>Discussion</H5>
<p class="description">The object which the function returns is internal. We do not recommend you to use this method if don't really need it. 
</p>
<HR>

<H3><A 
name=decl_SetPGaussian_DBN>SetPGaussian</A></H3>
<P class=Blurb>Sets parameters for one-dimensional gaussian variate 
We can set distribution only on 0 and 1 slices nodes, 
because on any i-th slices (i > 0) nodes distributions are the same.
</P>
<font class="interface">
void SetPGaussian(TokArr var, TokArr mean = TokArr(), TokArr variance = TokArr(), TokArr weight = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>var
  <DD>Name of node whose probability is set. 
  <DT>mean
  <DD>Vector of means. 
  <DT>variance
  <DD>Matrix of variance - one number for one-dimensional variate.
  <DT>weight
  <DD>Matrix of weights - vector for one-dimensional variate.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function set parameters for one-dimensional gaussian variate. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's set gaussian distribution for the node without parents.
</p>
<p class="example">
dbn.SetPGaussian("NodeA-0", "1.0", "4.0");
</p>
<p class="description">
Let's set gaussian distribution for the node with two parents.
</p>
<p class="example">
dbn.SetPGaussian("NodeA-0", "0.0", "2.0", "1.0 2.0");
</P>
<HR>

<H3><A 
name=decl_EditEvidence_DBN>EditEvidence</A></H3>
<P class=Blurb>Edits current evidence 
</P>
<font class="interface">
void EditEvidence(TokArr values);
</font>
<H5>Arguments</H5>
<DL>
  <DT>values
  <DD>Array of observed nodes with values.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets or edits current evidence. New observed nodes are added to current evidence
with EditEvidence method or old vales of observed nodes are changed. Every evidence may contains nodes from neighbour 
slices. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
</p>
<p class="example">
dbn.EditEvidence("NodeA-2^true NodeB-2^false");<br>
dbn.EditEvidence("NodeA-2^false NodeC-2^true");
</P>
<p class="description">
In current evidence there are three observed nodes now: "NodeA-2", "NodeB-2" (both are false) and "NodeC-2"(true).
</p>
<HR>

<H3><A 
name=decl_ClearEvid_DBN>ClearEvid</A></H3>
<P class=Blurb>Clears current evidence 
</P>
<font class="interface">
void ClearEvid();
</font>
<H5>Discussion</H5>
<p class="description">The function clears current evidence. 
</font>
<H5>
Example of usage
</H5>
<p class="example">
dbn.EditEvidence("NodeA-2^true NodeB-3^false");<br>
dbn.ClearEvid();
</P>
<p class="description">
Current evidence is empty now.
</p>
<HR>

<H3><A 
name=decl_CurEvidToBuf_DBN>CurEvidToBuf</A></H3>
<P class=Blurb>Stores current evidence to the evidence buffer 
</P>
<font class="interface">
void CurEvidToBuf();
</font>
<H5>Discussion</H5>
<p class="description">The function stores current evidence to the buffer of evedences. Current evidence is not cleared.
</font>
<H5>
Example of usage
</H5>
<p class="example">
dbn.EditEvidence("NodeA-2^true NodeB-3^false");<br>
dbn.EditEvidence("NodeA-2^false NodeC-2^true");<br>
dbn.CurEvidToBuf();<br>
dbn.EditEvidence("NodeB-3^true");<br>
dbn.CurEvidToBuf();
</P>
<p class="description">
In current evidence there are three observed nodes now: "NodeA-2" takes on value "false", "NodeB-3" and "NodeC-2" take on values "true".
</p>
<p class="description">
In evidence buffer there are two evidences now. In first evidence "NodeA"(slice 2) and "NodeB"(slice 3) take on values "false", and "NodeC-2"  
takes on value "true". In second one "NodeA-2" takes on value "false", "NodeB-3" and "NodeC-2" take on values "true".
</p>
<HR>

<H3><A 
name=decl_AddEvidToBuf_DBN>AddEvidToBuf</A></H3>
<P class=Blurb>Adds evidence to the evidence buffer 
</P>
<font class="interface">
void AddEvidToBuf(TokArr values);
</font>
<H5>Arguments</H5>
<DL>
  <DT>values
  <DD>Array of observed nodes with values.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds evidence to the buffer. Current evidence is not changed.
</font>
<H5>
Example of usage
</H5>
<p class="example">
dbn.AddEvidToBuf("NodeA-2^true NodeB-2^false");<br>
dbn.AddEvidToBuf("NodeA-1^false NodeC-2^true");
</P>
<p class="description">
In evidence buffer there are two evidences now. In first evidence "NodeA-2" takes on value "true" and "NodeB-2" takes on value "false".
In second one "NodeA-1" takes on value "false" and "NodeC-2" takes on value "true".
</p>
<HR>

<H3><A 
name=decl_ClearEvidBuf_DBN>ClearEvidBuf</A></H3>
<P class=Blurb>Clears evidence buffer 
</P>
<font class="interface">
void ClearEvidBuf();
</font>
<H5>Arguments</H5>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">The function clears evidence buffer. 
</font>
<H5>
Example of usage
</H5>
<p class="example">
dbn.AddEvidToBuf("NodeA-2^true NodeB-3^false");<br>
dbn.AddEvidToBuf("NodeA-1^false NodeC-1^true");<br>
dbn.ClearEvidBuf();
</P>
<p class="description">
Evidence buffer is empty now.
</p>
<HR>

<H3><A 
name=decl_MaskEvidBuf_DBN>MaskEvidBuf</A></H3>
<P class=Blurb>Hides nodes of current learning buffer with given probability 
</P>
<font class="interface">
void MaskEvidBuf(TokArr whatNodes = "");
</font>
<H5>Arguments</H5>
<DL>
  <DT>whatNodes
  <DD>Array of nodes.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function hides nodes of current learning buffer with given probability. The function applies for all existing 
values (hidden and observed), i.e. observed may become hidden and hidden may become observed. By default this function 
unhides all hidden values. If a node did not have sample then it can not be unhidden.
</font>
<H5>
Example of usage
</H5>
<p class="example">
</P>
<HR>

<H3><A 
name=decl_LearnParameters_DBN>LearnParameters</A></H3>
<P class=Blurb>Learns network parameters 
</P>
<font class="interface">
void LearnParameters();
</font>
<H5>Arguments</H5>
<DL>
  <DT>aValue
</DL>
<H5>
Example of usage
</H5>
<p class="description">
Function learns network with help of evidences buffer. See <A href="#decl_AddEvidToBuf_DBN">AddEvidToBuf</A>,
</p>
<p class="example">
dbn.LearnParameters();
</P>

<HR>

<H3><A 
name=decl_GetEMLearningCriterionValue_DBN>GetEMLearningCriterionValue</A></H3>
<P class=Blurb>Returns criterion value for last EM learning execution 
</P>
<font class="interface">
float GetEMLearningCriterionValue();
</font>
<H5>Discussion</H5>
<p class="description">
The function returns criterion value that was got during last EM learning
execution.
</p>
<H5>
Example of usage
</H5>
<p class="example">
dbn.LearnParameters();<br>
float resLogLik = dbn.GetEMLearningCriterionValue();
</P>
<HR>

<H3><A 
name=decl_GetMPE_DBN>GetMPE</A></H3>
<P class=Blurb>Returns MPE 
</P>
<font class="interface">
TokArr GetMPE(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes from one family.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns most probable explanation (MPE) for specified nodes using current evidence. 
</font>
<H5>
Example of usage
</H5>
<p class="description">
Get MPE for node "NodeA-0":
</p>
<p class="example">
TokArr jtreeMPENodeA = dbn.GetMPE("NodeA-0");
</P>
<p class="description">
Get MPE for nodes "NodeA-0" and "NodeB-0":
</p>
<p class="example">
TokArr pearlMPENodeA = dbn.GetMPE("NodeA-0 NodeB-0");
</P>
<HR>

<H3><A 
name=decl_GetJPD_DBN>GetJPD</A></H3>
<P class=Blurb>Returns JPD 
</P>
<font class="interface">
TokArr GetJPD(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes from one family.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns joint probability distribution (JPD) for specified nodes using current evidence. The inference algorithm
is set to property "Inference" with method <A href="#decl_SetProperty_DBN">SetProperty()</A>. By default Smoothing is used. Besides Filtering and 
FixLagSmoothing are availabile. Corresponding property "Inference" values are "smooth", "filt",
"fix".
</font>
<H5>
Example of usage
</H5>
<p class="description">
Get JPD for node "NodeA-3" with smoothing:
</p>
<p class="example">
dbn.SetProperty("Inference", "smooth");<br>
TokArr jtreeJPDNodeA = dbn.GetJPD("NodeA-3");
</P>
<p class="description">
Get JPD for nodes "NodeA-3" and "NodeB-3":
</p>
<p class="example">
dbn.SetProperty("Inference", "fix");<br>
TokArr pearlJPDNodeA = dbn.GetJPD("NodeA-0 NodeB-0");
</P>
<HR>

<H3><A 
name=decl_SetProperty_DBN>SetProperty</A></H3>
<P class=Blurb>Sets value to the property
</P>
<font class="interface">
void SetProperty(const char *name, const char *value);
</font>
<H5>Arguments</H5>
<DL>
  <DT>name
  <DD>Name of property. 
  <DT>value
  <DD>Array of nodes from one family.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets value to the property with given name. The function is used to specify algorithms
for inference and getting MPE and JPD and to specify parameters of algorithms. User can use this function to define his own
properties. Used properties names with their possible values and descriptions are presented in table:
</p>
<table width="100%">
<tr><td width="50pt" Rowspan="10"></td>
<td><table BORDER="1">
  <tr>
     <td width="20%"><center><b>Property Name</b></center></td>
     <td width="25%"><center><b>Possible Values</b></center></td>
     <td width="55%"><center><b>Description</b></center></td>
  </tr>
  <tr>
     <td>"Inference"</td>
     <td>"fix", "smooth", "filt","viter"</td>
     <td>Inference tasks. Smoothing is used by default. You must set Viterbi for getting MPE</td>
  </tr>
  
  <tr>
     <td>"InferenceAlgorithm"</td>
     <td>"1_5SliceJunctionTree", "Boyen-Koller"</td>
     <td>Inference algorithm that is used for getting MPE and JPD. 1_5SliceJunctionTree Inference is used by default.</td>
  </tr>
</table><tr></td>
</table>
<H5>
Example of usage
</H5>
<p class="description">
Set FixLagSmoothing inference for getting JPD by Boyen-Koller algorithm:
</p>
<p class="example">
dbn.SetProperty("InferenceAlgorithm", "Boyen-Koller");<br>
dbn.SetProperty("Inference", "fix");
</P>
<HR>

<H3><A 
name=decl_GetProperty_DBN>GetProperty</A></H3>
<P class=Blurb>Returns value of the property with given name
</P>
<font class="interface">
String GetProperty(const char *name) const;
</font>
<H5>Arguments</H5>
<DL>
  <DT>name
  <DD>Name of property.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns value of the property with given name. If property was not set with 
<A href="#decl_SetProperty_DBN">SetProperty</A> method then empty string is returned.
</p>
<H5>
Example of usage
</H5>
<p class="example">
dbn.SetProperty("Inference", "smooth");<br>
String inferenceType = dbn.GetProperty("Inference");<br>
</P>
<p class="description">
As result string inferenceType is "smooth".
</p>
<HR>

<H3><A 
name=decl_GetGaussianMean_DBN>GetGaussianMean</A></H3>
<P class=Blurb>Returns mean of gaussian distribution 
</P>
<font class="interface">
TokArr GetGaussianMean(TokArr node);
</font>
<H5>Arguments</H5>
<DL>
  <DT>node
  <DD>Name of node whose mean is needed</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns mean of gaussian distribution. 
</p>
<H5>
Example of usage
</H5>
<p class="example">
TokArr MeanNodeA0 = dbn.GetGaussianMean("NodeA-0");
</p>

<HR>

<H3><A 
name=decl_GetGaussianCovar_DBN>GetGaussianCovar</A></H3>
<P class=Blurb>Returns variance of gaussian distribution 
</P>
<font class="interface">
TokArr GetGaussianCovar(TokArr node);
</font>
<H5>Arguments</H5>
<DL>
  <DT>node
  <DD>Name of node whose variance is needed. 
</DL>
<H5>Discussion</H5>
<p class="description">The function returns variance of gaussian distribution. 
</p>
<H5>
Example of usage
</H5>
<p class="example">
TokArr CovarNodeA0 = dbn.GetGaussianCovar("NodeA-0");
</P>
<HR>

<H3><A 
name=decl_Unroll_DBN>Unroll</A></H3>
<P class=Blurb>Unrolls current Dynamic Bayessian Network
</P>
<font class="interface">
BayesNet* Unroll();
</font>
<H5>Discussion</H5>
<p class="description">The function unrolls current DBN. 
</font>
<H5>
Example of usage
</H5>
<p class="description">
Unrolling DBN :
</p>
<p class="example">
BayesNet *pnet;<br> 
pnet = dbn.Unroll();
</P>
<HR>

<H3><A 
name=decl_SaveNet_DBN>SaveNet</A></H3>
<P class=Blurb>Saves network to file 
</P>
<font class="interface">
void SaveNet(const char *filename);
</font>
<P>
<H5>Arguments</H5>
<DL>
  <DT>The name of the file where net should be saved.
  <DD>File name.</DD></DL>
<H5>Discussion</H5>
<p class="description">
The function saves network to file of "xml" format with given name. Net structure and nodes distributions 
of probabilities are stored to file.
</p>
<H5>
Example of usage
</H5>
<p class="example">
dbn.SaveNet("dbn.xml");
</P>
<HR>

<H3><A 
name=decl_SaveEvidBuf_DBN>SaveEvidBuf</A></H3>
<P class=Blurb>Saves evidence buffer content to file
</P>
<font class="interface">
int SaveEvidBuf(const char *filename, NetConst::ESavingType mode = NetConst::eCSV);
</font>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name. 
  <DT>mode
  <DD>Separating character depends on this parameter. Two separating characters are available: ',' (if mode is set to eCSV)
and tab (if mode is set to eTSV).</DD></DL>
<H5>Discussion</H5>
<p class="description">The function saves evidence buffer content to file of "cvs" format. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Save two evidences to file with ',' separator:
</p>
<p class="example">
dbn.ClearEvidBuf();<br>
dbn.AddEvidToBuf("NodeA-0^true NodeB-0^false");<br>
dbn.AddEvidToBuf("NodeA-1^false NodeC-1^true");<br>
dbn.SaveEvidBuf("evidence1.csv");
</P>
<p class="description">
Save the same two evidences to file with tab separator:
</p>
<p class="example">
dbn.ClearEvidBuf();<br>
dbn.AddEvidToBuf("NodeA-0^true NodeB-0^false");<br>
dbn.AddEvidToBuf("NodeA-1^false NodeC-1^true");<br>
dbn.SaveEvidBuf("evidence2.csv", NetConst::eTSV);
</P>
<HR>

<H3><A 
name=decl_LoadNet_DBN>LoadNet</A></H3>
<P class=Blurb>Loads network from file 
</P>
<font class="interface">
void LoadNet(const char *filename);
</font>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function loads network from file with given name. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Load net structure and distributions from file "dbn.xml":
</p>
<p class="example">
dbn.LoadNet("dbn.xml");
</P>
<HR>

<H3><A 
name=decl_LoadEvidBuf_DBN>LoadEvidBuf</A></H3>
<P class=Blurb>Loads evidence buffer content from file 
</P>
<pre>
<font class="interface">
int LoadEvidBuf(const char *filename, 
                NetConst::ESavingType mode = NetConst::eCSV, 
                TokArr columns = TokArr());
</font>
</pre>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name. 
  <DT>mode
  <DD>Separating character used in file is explained by this parameter. Two separating characters are available: 
',' (if mode is set to eCSV) and tab (if mode is set to eTSV). 
  <DT>columns
  <DD>Names of nodes.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function loads evidence buffer content from file. Buffer is cleared before loading. We can load evidences created in
another net with another node names but with the same values of nodes. For this we must set new node names in evidences 
using array "columns". The function returns number of evidences loaded from file.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Load evidences from file "evidence1.csv" with ',' separators and perform learning with them:
</p>
<p class="example">
dbn.LoadEvidBuf("evidence1.csv");<br>
dbn.LearnParameters();
</P>
<HR>
<!--
<H3><A 
name=decl_MakeUniformDistribution_DBN>MakeUniformDistribution</A></H3>
<P class=Blurb>Sets uniform distribution on all nodes 
</P>
<font class="interface">
void MakeUniformDistribution();
</font>
<H5>Arguments</H5>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">The function .... 
</font>
<H5>
Example of usage
</H5>
<p class="example">
</P>
<HR>
-->
<H3><A 
name=decl_GenerateEvidences_DBN>GenerateEvidences</A></H3>
<P class=Blurb>Generate samples for the network 
</P>
<font class="interface">
void GenerateEvidences(TokArr nEvSlices);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nEvSlices
  <DD>Number of samples on every slice to generate. 
</DL>
<H5>Discussion</H5>
<p class="description">The function generates the specified number of samples from joint probability distribution of the network.
The function allows generating samples with specified portion of missing variables. Parameter nEvSlices means number of generated 
samples on every slice. 
The newly generated samples will be saved to internal buffer (learning buffer). To clear learning buffer use <A href="#decl_ClearEvidBuf_DBN">ClearEvidBuf</A>. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Generate 100 samples on 0 slice and 50 on 1 slice: 
</p>
<p class="example">
GenerateEvidences("100 50");
</P>
<p class="description">
Generate 10 samples on 0 slice, 11 on 1 slice and 15 on 2 slice:
</p>
<p class="example">
GenerateEvidences("10 11 15");
</P>

<hr>
<H2><A name=decl_Class_LIMID>Class LIMID</A></H2>
<HR>

<P>Class LIMID implements all functionality required for work with LImited Memory Influence Diagrams. 
The following functional groups can be distinguished:
<UL>
    <LI>Network creation (addition/deletion of nodes and arcs)<BR>
    <A href="#decl_AddNode_LIMID">AddNode</A>,
    <A href="#decl_DelNode_LIMID">DelNode</A>,
    <A href="#decl_AddArc_LIMID">AddArc</A>,
    <A href="#decl_DelArc_LIMID">DelArc</A>.
    </LI>
    <LI>Setting/getting parameters<BR>
    <A href="#decl_SetPChance">SetPChance</A>,
    <A href="#decl_SetPDecision">SetPDecision</A>,
    <A href="#decl_SetValueCost">SetValueCost</A>,
    <A href="#decl_GetPChance">GetPChance</A>,
    <A href="#decl_GetPDecision">GetPDecision</A>,
    <A href="#decl_GetValueCost">GetValueCost</A>,
    <A href="#decl_SetProperty_LIMID">SetProperty</A>,
    <A href="#decl_GetProperty_LIMID">GetProperty</A>,
    <A href="#decl_Inference_LIMID">Inference</A>,
    <A href="#decl_Model_LIMID">Model</A>
    </LI>
    <LI>Getting utility<BR>
    <A href="#decl_GetExpectation">GetExpectation</A>,
    </LI>
    <LI>Getting pure politics<BR>
    <A href="#decl_GetPolitics">GetPolitics</A>
    </LI>
    <LI>File I/O<BR>
    <A href="#decl_LoadNet_LIMID">LoadNet</A>,
    <A href="#decl_SaveNet_LIMID">SaveNet</A>,
    </LI>
    <LI>more...</LI>
</UL>
<HR>


<H3><A name=decl_LIMID>LIMID</A></H3>
<P class=Blurb>Constructor</P>
<font class="interface">
LIMID();
</font>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">LIMID class has only default constructor.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Create empty LIMID:
</p>
<p class="example">
LIMID net;
</p>
<HR>

<H3><A name=decl_AddNode_LIMID>AddNode</A></H3>
<P class=Blurb>Adds nodes</P>
<font class="interface">
void AddNode(TokArr nodes, TokArr subnodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>List of nodes with nodes states specifying. 
  <DT>subnodes
  <DD>Array of values that nodes can take. 
</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds one or several nodes with the same probable states into the LIMID.</p>
<H5>
Example of usage
</H5>
<p class="description">
Add one chance node "NodeA" with states "true" and "false" to LIMID:
</p>
<p class="example">
net.AddNode(chance^"NodeA", "true false");
</p>
<p class="description">
Add one decision node "NodeB" with states "true" and "false" to LIMID:
</p>
<p class="example">
net.AddNode(decision^"NodeB", "true false");
</p>
<p class="description">
Add one value node "NodeC" with one state "cost" to LIMID:
</p>
<p class="example">
net.AddNode(value^"NodeC", "cost");
</p>
<HR>

<H3><A name=decl_DelNode_LIMID>DelNode</A></H3>
<P class=Blurb>Deletes nodes</P>
<font class="interface">
void DelNode(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of names of nodes to delete. 
  </DD></DL>
<H5>Discussion</H5>
<p class="description">The function deletes one or several nodes from LIMID together with all adjacent edges. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Delete nodes "NodeA" and "NodeB" from LIMID:
</p>
<p class="example">
net.DelNode("NodeA NodeB");
</P>
<HR>

<H3><A name=decl_AddArc_LIMID>AddArc</A></H3>
<P class=Blurb>Adds arc</P>
<font class="interface">
void AddArc(TokArr from, TokArr to);
</font>
<H5>Arguments</H5>
<DL>
  <DT>from
  <DD>Array of starting nodes of the arcs. 
  <DT>to
  <DD>Array of ending nodes of the arcs</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds one or several arcs to the LIMID. Each starting node is connected with each ending node.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Add edge from node "NodeA" to node "NodeB":
</p>
<p class="example">
net.AddArc("NodeA", "NodeB");
</P>
<p class="description">
Add two edges: from "NodeA" to "NodeB" and from "NodeA" to "NodeC":
</p>
<p class="example">
net.AddArc("NodeA", "NodeB NodeC");
</P>
<p class="description">
Add four edges: from "NodeA" to "NodeC", from "NodeA" to "NodeD", from "NodeB" to "NodeC" and from "NodeB" to "NodeD":
</p>
<p class="example">
net.AddArc("NodeA NodeB", "NodeC NodeD");
</P>
<HR>

<H3><A name=decl_DelArc_LIMID>DelArc</A></H3>
<P class=Blurb>Deletes arcs</P>
<font class="interface">
void DelArc(TokArr from, TokArr to);
</font>
<H5>Arguments</H5>
<DL>
  <DT>from
  <DD>Array of starting nodes of the arcs to delete. 
  <DT>to
  <DD>Array of ending nodes of the arcs to delete. 
  </DD></DL>
<H5>Discussion</H5>
<p class="description">The function deletes one or several arcs from the LIMID. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Delete edge from node "NodeA" to node "NodeB":
</p>
<p class="example">
net.DelArc("NodeA", "NodeB");
</P>
<p class="description">
Delete following two edges if they exist: from "NodeA" to "NodeB" and from "NodeA" to "NodeC":
</p>
<p class="example">
net.DelArc("NodeA", "NodeB NodeC");
</P>
<p class="description">
Delete all edges with starting node "NodeA" or "NodeB" and ending node "NodeC" or "NodeD":
</p>
<p class="example">
net.DelArc("NodeA NodeB", "NodeC NodeD");
</P>
<HR>

<H3><A 
name=decl_SetPChance>SetPChance</A></H3>
<P class=Blurb>Assigns probability to one or several values of one chance node 
</P>
<font class="interface">
void SetPChance(TokArr value, TokArr prob, TokArr parentValue = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>value
  <DD>Array of node values for wich probabilities are set. 
  <DT>prob
  <DD>Array of values of probabilities.
  <DT>parentValue
  <DD>Array of values of parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets [conditional] probability for one or several values of the chance node 
[for given values of parents]. Sizes of values array and probabilities array must be the same. While distribution 
of probabilities is not specified it is considered uniform.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's node "NodeA" has no parents and can take on two values: "true" and "false". Its distribution of probabilities is unconditional. 
</p>
<p class="example">
net.SetPChance("NodeA^true NodeA^false", "0.7 0.3");
</P>
<p class="description">
Let's node "NodeB" can take on values "true" and "false" too and has only one parent "NodeA". Distribution of 
probabilities of "NodeB" is conditional. It is necessary to call SetPChance method for each configuration of 
parents values:  
</p>
<p class="example">
net.SetPChance("NodeB^true NodeB^false", "0.99 0.01", "NodeA^true");<br>
net.SetPChance("NodeB^true NodeB^false", "0.4 0.6", "NodeA^false");
</P>
<HR>


<H3>
<A name=decl_SetPDecision>SetPDecision</A></H3>
<P class=Blurb>Assigns probability to one or several values of one decision node 
</P>
<font class="interface">
void SetPDecision(TokArr value, TokArr prob, TokArr parentValue = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>value
  <DD>Array of node values for wich probabilities are set. 
  <DT>prob
  <DD>Array of values of probabilities.
  <DT>parentValue
  <DD>Array of values of parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets [conditional] probability for one or several values of the decision node 
[for given values of parents]. Sizes of values array and probabilities array must be the same. While distribution 
of probabilities is not specified it is considered uniform.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's node "NodeA" has no parents and can take on two values: "true" and "false". Its distribution of probabilities is unconditional. 
</p>
<p class="example">
net.SetPDecision("NodeA^true NodeA^false", "0.7 0.3");
</P>
<p class="description">
Let's node "NodeB" can take on values "true" and "false" too and has only one parent "NodeA". Distribution of 
probabilities of "NodeB" is conditional. It is necessary to call SetPDecision method for each configuration of 
parents values:  
</p>
<p class="example">
net.SetPDecision("NodeB^true NodeB^false", "0.99 0.01", "NodeA^true");<br>
net.SetPDecision("NodeB^true NodeB^false", "0.4 0.6", "NodeA^false");
</P>
<HR>


<H3><A 
name=decl_SetValueCost>SetValueCost</A></H3>
<P class=Blurb>Assigns utility function to one value node 
</P>
<font class="interface">
void SetValueCost(TokArr value, TokArr cost, TokArr parentValue = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>value
  <DD>Array of node values for wich probabilities are set. 
  <DT>cost
  <DD>Array of cost values.
  <DT>parentValue
  <DD>Array of values of discrete parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets utility function for value node for given values of parents. While utility function is not specified each cost value equals zero.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's node "NodeB" can take on value "cost" and has one parent "NodeA". Let's node "NodeA" can take on two values: "true" and "false". To set utility function of "NodeB" it is necessary to call SetValueCost method for each configuration of parent values:  
</p>
<p class="example">
net.SetValueCost("NodeB^cost", "-1000.0", "NodeA^true");<br>
net.SetValueCost("NodeB^cost", "300.0", "NodeA^false");
</P>
<HR>


<H3><A 
name=decl_GetPChance>GetPChance</A></H3>
<P class=Blurb>Returns probability of chance node 
</P>
<font class="interface">
TokArr GetPChance(TokArr node, TokArr parents = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>node
  <DD>Name of node or array of node values whose probabilities are needed. 
  <DT>parents
  <DD>Values of parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns probability of chance node. If values of parents are given then probabilites only 
for these parents configuration will be returned. If concrete values of node are given in array node then
only probabilities of these values will be returned. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's consider getting of probabilities for node "NodeB" from example for SetPChance method. Some variants to get "NodeB"
probabilities are available:
</p>
<p class="example">
TokArr PNodeB = net.GetPChance("NodeB");<br>
TokArr PNodeBTrue = net.GetPChance("NodeB^true");<br>
TokArr PNodeBNodeATrue = net.GetPChance("NodeB", "NodeA^true");<br>
TokArr PNodeBTrueNodeAFalse = net.GetPChance("NodeB^true", "NodeA^false");
</P>
<p class="description">
Results of these calls:
</p>
<p class="example">
<table>
<tr>
  <td>PNodeB</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^false^NodeA^true^0.01 NodeB^true^NodeA^false^0.4 NodeB^false^NodeA^false^0.6"</td>
</tr>
<tr>
  <td>PNodeBTrue</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^true^NodeA^false^0.4"</td>
</tr>
<tr>
  <td>PNodeBNodeATrue</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^false^NodeA^true^0.01"</td>
</tr>
<tr>
  <td>PNodeBTrueNodeAFalse</td>
  <td>"NodeB^true^NodeA^false^0.4"</td>
</tr>
</table>
<HR>


<H3><A 
name=decl_GetPDecision>GetPDecision</A></H3>
<P class=Blurb>Returns probability of decision node 
</P>
<font class="interface">
TokArr GetPDecision(TokArr node, TokArr parents = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>node
  <DD>Name of node or array of node values whose probabilities are needed. 
  <DT>parents
  <DD>Values of parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns probability of decision node. If values of parents are given then probabilities only 
for these parents configuration will be returned. If concrete values of node are given in array node then
only probabilities of these values will be returned. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's consider getting of probabilities for node "NodeB" from example for SetPDecision method. Some variants to get "NodeB"
probabilities are available:
</p>
<p class="example">
TokArr PNodeB = net.GetPDecision("NodeB");<br>
TokArr PNodeBTrue = net.GetPDecision("NodeB^true");<br>
TokArr PNodeBNodeATrue = net.GetPDecision("NodeB", "NodeA^true");<br>
TokArr PNodeBTrueNodeAFalse = net.GetPDecision("NodeB^true", "NodeA^false");
</P>
<p class="description">
Results of these calls:
</p>
<p class="example">
<table>
<tr>
  <td>PNodeB</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^false^NodeA^true^0.01 NodeB^true^NodeA^false^0.4 NodeB^false^NodeA^false^0.6"</td>
</tr>
<tr>
  <td>PNodeBTrue</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^true^NodeA^false^0.4"</td>
</tr>
<tr>
  <td>PNodeBNodeATrue</td>
  <td>"NodeB^true^NodeA^true^0.99 NodeB^false^NodeA^true^0.01"</td>
</tr>
<tr>
  <td>PNodeBTrueNodeAFalse</td>
  <td>"NodeB^true^NodeA^false^0.4"</td>
</tr>
</table>
<HR>

<H3><A 
name=decl_GetValueCost>GetValueCost</A></H3>
<P class=Blurb>Returns utility function of value node 
</P>
<font class="interface">
TokArr GetValueCost(TokArr node, TokArr parents = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>node
  <DD>Name of node or array of node values whose utility function are needed. 
  <DT>parents
  <DD>Values of parents of the node.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns utility function of value node. If values of parents are given then probabilites only 
for these parents configuration will be returned. If concrete values of node are given in array node then
only probabilities of these values will be returned. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's consider getting of utility function for node "NodeB" from example for SetValueCost method. Some variants to get "NodeB"
utility function are available:
</p>
<p class="example">
TokArr PNodeB = net.GetValueCost("NodeB");<br>
TokArr PNodeBNodeATrue = net.GetValueCost("NodeB", "NodeA^true");<br>
TokArr PNodeBTrueNodeAFalse = net.GetValueCost("NodeB^cost", "NodeA^false");
</P>
<p class="description">
Results of these calls:
</p>
<p class="example">
<table>
<tr>
  <td>PNodeB</td>
  <td>"NodeB^cost^NodeA^true^-1000.0 NodeB^cost^NodeA^false^300.0"</td>
</tr>
<tr>
  <td>PNodeBNodeATrue</td>
  <td>"NodeB^cost^NodeA^true^-1000.0"</td>
</tr>
<tr>
  <td>PNodeBTrueNodeAFalse</td>
  <td>"NodeB^cost^NodeA^false^300.0"</td>
</tr>
</table>
<HR>


<H3><A 
name=decl_GetExpectation>GetExpectation</A></H3>
<P class=Blurb>Returns expected utility 
</P>
<font class="interface">
TokArr GetExpectation();
</font>
<H5>Discussion</H5>
<p class="description">The function returns expected utility.
</font>
<H5>
Example of usage
</H5>
<p class="example">
TokArr exp = net.GetExpectation();<br>
</P>
<HR>

<H3><A 
name=decl_GetPolitics>GetPolitics</A></H3>
<P class=Blurb>Returns pure politics 
</P>
<font class="interface">
TokArr GetPolitics();
</font>
<H5>Discussion</H5>
<p class="description">The function returns pure politics. 
<H5>
Example of usage
</H5>
<p class="example">
TokArr politics = net.GetPolitics();<br>
</P>
<HR>

<H3><A 
name=decl_SetProperty_LIMID>SetProperty</A></H3>
<P class=Blurb>Sets value to the property
</P>
<font class="interface">
void SetProperty(const char *name, const char *value);
</font>
<H5>Arguments</H5>
<DL>
  <DT>name
  <DD>Name of property. 
  <DT>value
  <DD>Value of property.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets value to the property with given name. User can use this function to define his own
properties. 
</p>

<H5>
Example of usage
</H5>
<p class="description">
Set property "MyProperty":
</p>
<p class="example">
net.SetProperty("MyProperty", "PropValue");
</P>
<HR>

<H3><A 
name=decl_GetProperty_LIMID>GetProperty</A></H3>
<P class=Blurb>Returns value of the property with given name
</P>
<font class="interface">
String GetProperty(const char *name) const;
</font>
<H5>Arguments</H5>
<DL>
  <DT>name
  <DD>Name of property.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns value of the property with given name. If property was not set with 
<A href="#decl_SetProperty">SetProperty</A> method then empty string is returned.
</p>
<H5>
Example of usage
</H5>
<p class="example">
net.SetProperty("MyProperty", "PropValue");<br>
String Property = net.GetProperty("MyProperty");<br>
</P>
<p class="description">
As result string Property is "PropValue".
</p>
<HR>

<H3><A 
name=decl_Inference_LIMID>Inference</A></H3>
<P class=Blurb>Returns a reference to the object of pnl::CLIMIDInfEngine class which corresponds to the current LIMID object 
</P>
<font class="interface">
pnl::CLIMIDInfEngine& Inference();
</font>
<H5>Discussion</H5>
<p class="description">The object which the function returns is internal. We do not recommend you to use this method if don't really need it. 
</p>
<HR>

<H3><A 
name=decl_Model_LIMID>Model</A></H3>
<P class=Blurb>Returns a reference to the object of pnl::CIDNet class which corresponds to the current LIMID object 
</P>
<font class="interface">
pnl::CIDNet &Model();
</font>
<H5>Discussion</H5>
<p class="description">The object which the function returns is internal. We do not recommend you to use this method if don't really need it. 
</p>
<HR>

<H3><A 
name=decl_SaveNet_LIMID>SaveNet</A></H3>
<P class=Blurb>Saves LIMID to file
</P>
<font class="interface">
void SaveNet(const char *filename);
</font>
<P>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name.</DD></DL>
<H5>Discussion</H5>
<p class="description">
The function saves LIMID to file of "xml" format with given name. LIMID structure and nodes distributions 
of probabilities are stored to file.
</p>
<H5>
Example of usage
</H5>
<p class="example">
net.SaveNet("net.xml");
</P>
<HR>


<H3><A 
name=decl_LoadNet_LIMID>LoadNet</A></H3>
<P class=Blurb>Loads LIMID from file 
</P>
<font class="interface">
void LoadNet(const char *filename);
</font>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function loads LIMID from file with given name. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Load LIMID structure and distributions from file "net.xml":
</p>
<p class="example">
net.LoadNet("net.xml");
</P>
<HR>
<H2><A name=decl_Class_MRF>Class MRF</A></H2>
<HR>

<P>Class MRF implements all functionality required for work with MRF networks. 
The following functional groups can be distinguished:
<UL>
    <LI>Network creation (addition/deletion of nodes and arcs)<BR>
    <A href="#decl_AddNode_MRF">AddNode</A>,
    <A href="#decl_DelNode_MRF">DelNode</A>,
    <A href="#decl_GetNumberOfNodes_MRF">GetNumberOfNodes</A>,
    <A href="#decl_SetClique_MRF">SetClique</A>,
    <A href="#decl_DestroyClique_MRF">DestroyClique</A>,
    <A href="#decl_GetNumberOfCliques_MRF">GetNumberOfCliques</A>
    </LI>
    <LI>Setting/getting parameters<BR>
    <A href="#decl_SetPTabular_MRF">SetPTabular</A>,
    <A href="#decl_GetPTabular_MRF">GetPTabular</A>,
    <A href="#decl_EditEvidence_MRF">EditEvidence</A>,
    <A href="#decl_ClearEvid_MRF">ClearEvid</A>,
    <A href="#decl_CurEvidToBuf_MRF">CurEvidToBuf</A>,
    <A href="#decl_AddEvidToBuf_MRF">AddEvidToBuf</A>,
    <A href="#decl_ClearEvidBuf_MRF">ClearEvidBuf</A>,
    <A href="#decl_GetChildren_MRF">GetChildren</A>,
    <A href="#decl_GetParents_MRF">GetParents</A>,
    <A href="#decl_GetNeighbours_MRF">GetNeighbours</A>,
    <A href="#decl_SetProperty_MRF">SetProperty</A>,
    <A href="#decl_GetProperty_MRF">GetProperty</A>,
    <A href="#decl_GetPNLEvidence_MRF">GetPNLEvidence</A>,
    <A href="#decl_Inference_MRF">Inference</A>,
    <A href="#decl_Learning_MRF">Learning</A>,
    <A href="#decl_Model_MRF">Model</A>

    </LI>
    <LI>Learning parameters<BR>
    <A href="#decl_LearnParameters_MRF">LearnParameters</A>
    </LI>
    <LI>Learning network structure<BR>
    <A href="#decl_LearnStructure_MRF">LearnStructure</A>
    </LI>
    <LI>Inference in network<BR>
    <A href="#decl_GetJPD_MRF">GetJPD</A>,
    <A href="#decl_GetMPE_MRF">GetMPE</A>
    </LI>
    <LI>Data sampling<BR>
    <A href="#decl_GenerateEvidences_MRF">GenerateEvidences</A>
    </LI>
    <LI>File I/O<BR>
    <A href="#decl_LoadNet_MRF">LoadNet</A>,
    <A href="#decl_SaveNet_MRF">SaveNet</A>,
    <A href="#decl_LoadEvidBuf_MRF">LoadEvidBuf</A>,
    <A href="#decl_SaveEvidBuf_MRF">SaveEvidBuf</A>
    </LI>
    <LI>more...</LI>
</UL>
<HR>


<H3><A name=decl_MRF>MRF</A></H3>
<P class=Blurb>Constructor</P>
<font class="interface">
MRF();
</font>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">MRF class has only default constructor.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Create empty MRF:
</p>
<p class="example">
MRF net;
</p>
<HR>

<H3><A name=decl_AddNode_MRF>AddNode</A></H3>
<P class=Blurb>Adds nodes</P>
<font class="interface">
void AddNode(TokArr nodes, TokArr subnodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>List of nodes with node types (discrete or continuous) specifying. 
  <DT>subnodes
  <DD>Array of values that nodes can take (or names of dimensions for continuous nodes). 
</DD></DL>
<H5>Discussion</H5>
<p class="description">This function adds one or several nodes with the same probable states into the network.</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's add one discrete node "NodeA" with states "true" and "false" to the net:
</p>
<p class="example">
net.AddNode(discrete^"NodeA", "true false");
</p>
<!--
<p class="description">
Add one-dimensional continuous node "NodeA" to net:
</p>
<p class="example">
net.AddNode(continuous^"NodeA", "dim1");
-->
<p class="description">
Now we are going to add discrete nodes "NodeA" and "NodeB" with states "true" and "false" to
the net:
</p>
<p class="example">
net.AddNode(discrete^"NodeA NodeB", "true false");
</p>
<!--
<p class="description">
Add multivariate nodes "NodeA" with 2 dimensions "dim1" and "dim2" to net:
</p>
<p class="example">
net.AddNodee(continuous^"NodeA", "dim1 dim2");
</p>
-->
<HR>

<H3><A name=decl_DelNode_MRF>DelNode</A></H3>
<P class=Blurb>Deletes nodes</P>
<font class="interface">
void DelNode(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of node names, that we want to delete. 
  </DD></DL>
<H5>Discussion</H5>
<p class="description">The function deletes one or several nodes from network. All cliques,
that contains these nodes, are destroyed. 
</p>
<H5>
Example of usage
</H5>
<p class="description">The following call deletes &quot;NodeA&quot; and &quot;NodeB&quot;
nodes from net:
</p>
<p class="example">
net.DelNode("NodeA NodeB");
</P>
<HR>

<H3><A name=decl_GetNodeType_MRF>GetNodeType</A></H3>
<P class=Blurb>Returns types of the given nodes</P>
<font class="interface">
TokArr GetNodeType(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of node names. We are interesting in types of these nodes. 
</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns array of given nodes types (discrete or
continuous).
</p>
<H5>
Example of usage
</H5>
<p class="description">
The following function call gets array of node types for &quot;NodeA&quot; and
&quot;NodeB&quot; nodes:
</p>
<p class="example">
   TokArr nodeTypes = net.GetNodeType("NodeA NodeB");
</P>
<HR>

<H3><A name=decl_GetNumberOfNodes_MRF>GetNumberOfNodes</A></H3>
<P class=Blurb>Returns number of nodes</P>
<font class="interface">
int GetNumberOfNodes() const;
</font>
<H5>Discussion</H5>
<p class="description">The function returns number of nodes in network.
</p>
<H5>
Example of usage
</H5>
<p class="example">
   int N = net.GetNumberOfNodes();
</P>
<HR>

<H3><A name=decl_SetClique_MRF>SetClique</A></H3>
<P class=Blurb>Joins nodes into a clique</P>
<font class="interface">
void SetClique(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes for new clique. 
</DD></DL>
<H5>Discussion</H5>
<p class="description">This function joins nodes into a clique. Default uniform distribution is
set on the clique. 
Clique may also be formed with <A href="#decl_SetPTabular_MRF">SetPTabular</A> method. 
</p>
<H5>
Example of usage
</H5>
<p class="description">Next instruction joins &quot;NodeA&quot; and &quot;NodeB&quot;
nodes to a clique:
</p>
<p class="example">
net.SetClique("NodeA", "NodeB");
</P>
<HR>

<H3><A name=decl_DestroyClique_MRF>DestroyClique</A></H3>
<P class=Blurb>Destroys clique</P>
<font class="interface">
void DestroyClique(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Node array of clique, that is destroyed. 
  </DD></DL>
<H5>Discussion</H5>
<p class="description">The function destroys clique. Nodes are not deleted from the network.
</p>
<H5>
Example of usage
</H5>
<p class="description">Let's destroy clique of &quot;NodeA&quot; and &quot;NodeB&quot;nodes:
</p>
<p class="example">
net.DestroyClique("NodeA", "NodeB");
</P>
<HR>

<H3><A name=decl_GetNumberOfCliques_MRF>GetNumberOfCliques</A></H3>
<P class=Blurb>Returns number of cliques</P>
<font class="interface">
int GetNumberOfCliques() const;
</font>
<H5>Discussion</H5>
<p class="description">The function returns number of cliques in network.
</p>
<H5>
Example of usage
</H5>
<p class="example">
   int N = net.GetNumberOfNodes();
</P>
<HR>

<H3><A 
name=decl_SetPTabular_MRF>SetPTabular</A></H3>
<P class=Blurb>Assigns probability to one or several values combinations of the nodes
in one discrete clique 
</P>
<font class="interface">
void SetPTabular(TokArr value, TokArr prob);
</font>
<H5>Arguments</H5>
<DL>
  <DT>value
  <DD>Values of nodes in one clique, for which probabilities are set. 
  <DT>prob
  <DD>Array of probability values .</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets probability to one or several values combinations of the nodes
in one discrete clique. If clique doesn't exist, then it will be created. In value array a node may be specified without value. It means
that probabilities will be set for values combinations with all values of this node in the same order as values were
specified with <A href="#decl_AddNode_MRF">AddNode</A> method for the node. If distribution 
of probabilities is not specified it is considered as uniform.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Consider &quot;NodeA&quot; and &quot;NodeB&quot; nodes both can take on one of two values: "true" and
&quot;false&quot;. Let's join them into clique and set probabilities for some of
their values: 
</p>
<p class="example">
net.SetPTabular("NodeA^true NodeB^false", "0.3");
</P>
<p class="description">
Let's consider how to specify some values of probabilities for clique omitting values for nodes:  
</p>
<p class="example">
net.AddNode("NodeA NodeB", "true false");<br>
net.SetPTabular("NodeB NodeA", "0.01 0.46 0.3 0.22");<br>
</P>
<p class="description">
This SetPTabular() calling form new clique of nodes "NodeA" and "NodeB" with folowing probabilities:
<table width=100%>
<tr>
  <td width=10%>NodeB</td><td width=10%>NodeA</td><td width=80%>Probability</td>
<tr>
<tr>
  <td>true</td><td>true</td><td>0.01</td>
<tr>
<tr>
  <td>true</td><td>false</td><td>0.46</td>
<tr>
<tr>
  <td>false</td><td>true</td><td>0.3</td>
<tr>
<tr>
  <td>false</td><td>false</td><td>0.22</td>
<tr>
</table>
<HR>

<H3><A 
name=decl_GetPTabular_MRF>GetPTabular</A></H3>
<P class=Blurb>Returns probability distribution of discrete clique 
</P>
<font class="interface">
TokArr GetPTabular(TokArr value);
</font>
<H5>Arguments</H5>
<DL>
  <DT>value
  <DD>Array of clique nodes and node values, whose probabilities are needed.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns probability of discrete clique. If values of node are
specified in 
node array, only probabilities of these values will be returned. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's consider getting the probabilities for clique, which is formed of &quot;NodeA&quot; and
&quot;NodeB&quot; nodes from example in previous section. 
Some variants of getting the probabilites are available:
</p>
<p class="example">
TokArr PNodeATrue = net.GetPTabular("NodeA^true NodeB");<br>
TokArr PNodeAFalseNodeBTrue = net.GetPTabular("NodeB^true NodeA^false");<br>
TokArr PNodeANodeB = net.GetPTabular("NodeA NodeB");<br>
</P>
<p class="description">
Here are the results of these calls:
</p>
<p class="example">
<table>
<tr>
  <td>PNodeATrue</td>
  <td>"NodeA^true^NodeB^true^0.01 NodeA^true^NodeB^false^0.3</td>
</tr>
<tr>
  <td>PNodeAFalseNodeBTrue</td>
  <td>"NodeB^true^NodeA^false^0.46"</td>
</tr>
<tr>
  <td>PNodeBNodeATrue</td>
  <td>"NodeA^true^NodeB^true^0.01 
       NodeA^true^NodeB^false^0.3 
       NodeA^false^NodeB^true^0.46 
       NodeA^false^NodeB^false^0.22"</td>
</tr>
</table>
<HR>

<!--
<H3><A 
name=decl_SetPGaussian_MRF>SetPGaussian</A></H3>
<P class=Blurb>Sets parameters for gaussian variate. 
</P>
<font class="interface">
void SetPGaussian(TokArr var, TokArr mean = TokArr(), TokArr variance = TokArr(), TokArr weight = TokArr());
</font>
<H5>Arguments</H5>
<DL>
  <DT>var
  <DD>Name of node which probability is setted. 
  <DT>mean
  <DD>Vector of means. 
  <DT>variance
  <DD>Matrix of variance (for one-dimensional variate it is only one number).
  <DT>weight
  <DD>Matrixes of weights. This parameter is needed only when the node has parents. For more details about matrixes of weights see User Guide, chapter "Multivariate Gaussian case" 
</DL>
<H5>Discussion</H5>
<p class="description">The function sets parameters for gaussian variate. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Let's set gaussian distribution for one - dimentional node without parents.
</p>
<p class="example">
net.SetPGaussian("x0", "1.0", "4.0");
</p>
<p class="description">
Let's set gaussian distribution for one - dimentional node with two parents.
</p>
<p class="example">
net.SetPGaussian("x2", "0.0", "2.0", "1.0 2.0");
</P>
<p class="description">
Let's set gaussian distribution for two - dimensional node without parents.
</p>
<p class="example">
net.SetPGaussian("x0", "1.0 2.5", "4.0 0.1 0.1 4.0");
</p>
<p class="description">
Let's set gaussian distribution for two - dimentional node with three two - dimensional parents. Three matrixes of weights are:
</p>
<p class="description">
<table>
<tr>
  <td>The first matrix</td>
  <td>1.0</td>
  <td>2.0</td>
  <td>The second</td>
  <td>5.0</td>
  <td>6.0</td>
  <td>The third</td>
  <td>9.0</td>
  <td>10.0</td>
</tr>
<tr>
  <td></td>
  <td>3.0</td>
  <td>4.0</td>
  <td></td>
  <td>7.0</td>
  <td>8.0</td>
  <td></td>
  <td>11.0</td>
  <td>12.0</td>
</tr>
</table>
</p>
<p class="example">
net.SetPGaussian("x2", "1.0 2.5", "4.0 0.1 0.1 4.0", "1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0");
</P>
<HR>
-->

<H3><A 
name=decl_EditEvidence_MRF>EditEvidence</A></H3>
<P class=Blurb>Edits current evidence 
</P>
<font class="interface">
void EditEvidence(TokArr values);
</font>
<H5>Arguments</H5>
<DL>
  <DT>values
  <DD>Array of observed nodes with values.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets or edits current evidence. New observed nodes are added to current evidence
with EditEvidence method or old values of observed nodes are changed.
</p>
<H5>
Example of usage
</H5>
<p class="description">
</p>
<p class="example">
net.EditEvidence("NodeA^true NodeB^false");<br>
net.EditEvidence("NodeA^false NodeC^true");
</P>
<p class="description">
In current evidence there are three observed tabular nodes: "NodeA", "NodeB" (both are false) and "NodeC"(true).
</p>
<HR>

<H3><A 
name=decl_ClearEvid_MRF>ClearEvid</A></H3>
<P class=Blurb>Clears current evidence 
</P>
<font class="interface">
void ClearEvid();
</font>
<H5>Discussion</H5>
<p class="description">The function clears current evidence. 
</font>
<H5>
Example of usage
</H5>
<p class="example">
net.EditEvidence("NodeA^true NodeB^false");<br>
net.ClearEvid();
</P>
<p class="description">
Current evidence is empty now.
</p>
<HR>

<H3><A 
name=decl_CurEvidToBuf_MRF>CurEvidToBuf</A></H3>
<P class=Blurb>Stores current evidence to the evidence buffer 
</P>
<font class="interface">
void CurEvidToBuf();
</font>
<H5>Discussion</H5>
<p class="description">The function stores current evidence to the buffer of
evedences.&nbsp; Current evidence is not cleared after this action.
<H5>
Example of usage
</H5>
<p class="example">
net.EditEvidence("NodeA^true NodeB^false");<br>
net.EditEvidence("NodeA^false NodeC^true");<br>
net.CurEvidToBuf();<br>
net.EditEvidence("NodeB^true");<br>
net.CurEvidToBuf();
</P>
<p class="description">There are three observed nodes in current evidence now:
&quot;NodeA&quot; takes on &quot;false&quot; value , "NodeB" and "NodeC" take on
&quot;true&quot; value.
</p>
<p class="description">There are two evidences in evidence buffer&nbsp; now. In first evidence "NodeA" and "NodeB" take on
&quot;false&quot; value, and "NodeC" 
takes on &quot;true&quot; value. In second one "NodeA" takes on &quot;false&quot;
value, "NodeB" and "NodeC" take on &quot;true&quot; value .
</p>
<HR>

<H3><A 
name=decl_AddEvidToBuf_MRF>AddEvidToBuf</A></H3>
<P class=Blurb>Adds evidence to the evidence buffer 
</P>
<font class="interface">
void AddEvidToBuf(TokArr values);
</font>
<H5>Arguments</H5>
<DL>
  <DT>values
  <DD>Array of observed nodes with values.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function adds evidence to the buffer. After this
action current evidence is not changed.
<H5>
Example of usage
</H5>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");
</P>
<p class="description">There are two evidences in evidence buffer now. In first evidence "NodeA" takes on
&quot;true&quot; value and "NodeB" takes on &quot;false&quot; value.
In second one "NodeA" takes on &quot;false&quot; value and "NodeC" takes on
&quot;true&quot; value.
</p>
<HR>

<H3><A 
name=decl_ClearEvidBuf_MRF>ClearEvidBuf</A></H3>
<P class=Blurb>Clears evidence buffer 
</P>
<font class="interface">
void ClearEvidBuf();
</font>
<H5>Arguments</H5>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">The function clears evidence buffer. 
</font>
<H5>
Example of usage
</H5>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.ClearEvidBuf();
</P>
<p class="description">
Evidence buffer is empty now.
</p>
<HR>

<H3><A 
name=decl_MaskEvidBuf_MRF>MaskEvidBuf</A></H3>
<P class=Blurb>Hides nodes of current learning buffer with given probability 
</P>
<font class="interface">
void MaskEvidBuf(TokArr whatNodes = "");
</font>
<H5>Arguments</H5>
<DL>
  <DT>whatNodes
  <DD>Array of nodes.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function hides nodes of current learning buffer with given probability. The function applies for all existing 
values (hidden and observed), i.e. observed may become hidden and hidden may become observed. By default this function 
unhides all hidden values. If a node did not have sample then it can not be unhidden.
</font>
<H5>
Example of usage
</H5>
<p class="example">
</P>
<HR>

<H3><A 
name=decl_LearnParameters_MRF>LearnParameters</A></H3>
<P class=Blurb>Learns network parameters 
</P>
<font class="interface">
void LearnParameters(TokArr aValue[] = NULL, int nValue = 0);
</font>
<H5>Arguments</H5>
<DL>
  <DT>aValue
  <DD>Array of evidences. Each evidence is array of observed nodes with values. 
  <DT>nValue
  <DD>Number of evidences.</DD></DL>
<H5>Discussion</H5>
<p class="description">
The function learns network parameters using evidence buffer. If function is called
with arguments, new 
evidences are added to evidence buffer and learning is started up. EM learning algorithm
is used for parameters learning.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Folowing three code pieces are equal:
</p>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.LearnParameters();
</P>
<p class="example">
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
TokArr evidences[] = {"NodeA^false NodeC^true"};<br>
net.LearnParameters(evidences);
</P>
<p class="example">
TokArr evidences[] = {"NodeA^true NodeB^false", "NodeA^false NodeC^true"};<br>
net.LearnParameters(evidences);
</P>
<HR>

<H3><A 
name=decl_GetMPE_MRF>GetMPE</A></H3>
<P class=Blurb>Returns MPE 
</P>
<font class="interface">
TokArr GetMPE(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes from one clique.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns most probable explanation (MPE) for specified nodes using current evidence. The
desired inference algorithm
may be set to &quot;Inference&quot; property with the help of <A href="#decl_SetProperty_MRF">SetProperty()</A>
method. Junction Tree inference engine is used by default . Besides Gibbs
sampling
and Naive inference are available. If network is MRF2 (all cliques consist of two
nodes), Pearl inference can be used.
Corresponding &quot;Inference&quot; property values are "jtree", "gibbs", "naive" and "pearl".
<H5>
Example of usage
</H5>
<p class="description">Let's get MPE for &quot;NodeA&quot; node with Pearl inference:
</p>
<p class="example">
net.SetProperty("Inference", "pearl");<br>
TokArr jtreeMPENodeA = net.GetMPE("NodeA");
</P>
<p class="description">The following function call gets MPE for &quot;NodeA&quot; and
&quot;NodeB&quot; nodes&nbsp; with Junction Tree inference (&quot;NodeA&quot; and
&quot;NodeB&quot; nodes have to be from one family):
</p>
<p class="example">
net.SetProperty("Inference", "jtree");<br>
TokArr pearlMPENodeA = net.GetMPE("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_GetJPD_MRF>GetJPD</A></H3>
<P class=Blurb>Returns JPD 
</P>
<font class="interface">
TokArr GetJPD(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Array of nodes from one family.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns joint probability distribution (JPD) for specified nodes using current evidence. The inference algorithm
may be set to &quot;Inference&quot; property&nbsp; with <A href="#decl_SetProperty_MRF">SetProperty()</A>
method. Junction Tree inference engine is used by default. Besides Gibbs
sampling
and Naive inference are available. If network is MRF2 (all cliques consist of two nodes) then Pearl inference can be used.
Corresponding property "Inference" values are "jtree", "gibbs", "naive" and "pearl".
<H5>
Example of usage
</H5>
<p class="description">
Get JPD for &quot;NodeA&quot; node with Junction Tree inference:
</p>
<p class="example">
net.SetProperty("Inference", "jtree");<br>
TokArr jtreeJPDNodeA = net.GetJPD("NodeA");
</P>
<p class="description">The following function call gets JPD for &quot;NodeA&quot; and
&quot;NodeB&quot; nodes&nbsp; with Pearl inference (&quot;NodeA&quot; and &quot;NodeB&quot;
nodes have to be from one family):
</p>
<p class="example">
net.SetProperty("Inference", "pearl");<br>
TokArr pearlJPDNodeA = net.GetJPD("NodeA NodeB");
</P>
<HR>

<H3><A 
name=decl_SetProperty_MRF>SetProperty</A></H3>
<P class=Blurb>Sets value to the property
</P>
<font class="interface">
void SetProperty(const char *name, const char *value);
</font>
<H5>Arguments</H5>
<DL>
  <DT>name
  <DD>Name of property. 
  <DT>value
  <DD>Value of property.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function sets value to the property with given name. The function is used
for specifying algorithms
for learning, getting MPE and JPD and to specify parameters of algorithms. User can use this function to define his own
properties. Available properties names with their possible values and descriptions are presented in table:
</p>
<table width="100%">
<tr><td width="50pt" Rowspan="10"></td>
<td><table BORDER="1">
  <tr>
     <td width="20%"><center><b>Property Name</b></center></td>
     <td width="25%"><center><b>Possible Values</b></center></td>
     <td width="55%"><center><b>Description</b></center></td>
  </tr>
  <tr>
     <td>"Learning"</td>
     <td>"bayes", "em"</td>
     <td>Algorithm for parameters learning. EM Learning is used by default.</td>
  </tr>
  <tr>
     <td>"EMMaxNumberOfIterations"</td>
     <td>Any positive integer number</td>
     <td>Maximum number of iterations of EM Learning algorithm. Default value is 5.</td>
  </tr>
  <tr>
     <td>"EMTolerance"</td>
     <td>Any positive float number</td>
     <td>Precision that  EM Learning algorithm runs up to. Default value is 0.001.</td>
  </tr>
  <tr>
     <td>"Inference"</td>
     <td>"pearl", "jtree", "gibbs", "naive"</td>
     <td>Inference algorithm that is used for getting MPE and JPD. Pearl Inference is used by default.</td>
  </tr>
  <tr>
     <td>"PearlMaxNumberOfIterations"</td>
     <td>Any positive integer number</td>
     <td>Maximum number of iterations of Pearl Inference algorithm. Default value is equal to number of nodes
      in the net.</td>
  </tr>
  <tr>
     <td>"PearlTolerance"</td>
     <td>Any positive float number</td>
     <td>Precision that Pearl Inference algorithm runs up to. Default value is 1e-6.</td>
  </tr>
  <tr>
     <td>"GibbsNumberOfIterations"</td>
     <td>Any positive integer number</td>
     <td>Number of iterations of Gibbs Sampling Inference algorithm. Default value is 600.</td>
  </tr>
  <tr>
     <td>"GibbsThresholdIteration"</td>
     <td>Any positive integer number less than GibbsNumberOfIterations value</td>
     <td>Number of first itearation that use samples processing results of the previous iteration. Default value is 10.</td>
  </tr>
  <tr>
     <td>"GibbsNumberOfStreams"</td>
     <td>Any positive integer number</td>
     <td>Number of streams that generate independent samples. Default value is 1.</td>
  </tr>
</table>
</table>
<H5>
Example of usage
</H5>
<p class="description">
Let's set Pearl inference for getting MPE and JPD:
</p>
<p class="example">
net.SetProperty("Inference", "pearl");
</P>
<p class="description">
Then set maximum of iterations for Pearl inference:
</p>
<p class="example">
net.SetProperty("PearlMaxNumberOfIterations", "50");
</P>
<p class="description">
Any other property can be defined by user:
</p>
<p class="example">
net.SetProperty("IterationsNumber", "100");
</P>
<HR>

<H3><A 
name=decl_GetProperty_MRF>GetProperty</A></H3>
<P class=Blurb>Returns value of the property with given name
</P>
<font class="interface">
String GetProperty(const char *name) const;
</font>
<H5>Arguments</H5>
<DL>
  <DT>name
  <DD>Name of property.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns value of the property with given name. If property was not set with 
<A href="#decl_SetProperty_MRF">SetProperty</A> method, empty string is returned.
</p>
<H5>
Example of usage
</H5>
<p class="example">
net.SetProperty("Inference", "pearl");<br>
String inferenceType = net.GetProperty("Inference");<br>
String learningType = net.GetProperty("Learning");
</P>
<p class="description">
As result string inferenceType is "pearl" and string learningType is empty.
</p>
<HR>

<H3><A 
name=decl_GetPNLEvidence_MRF>GetPNLEvidence</A></H3>
<P class=Blurb>Returns a pointer to the evidence (object of pnl::CEvidence class) 
</P>
<font class="interface">
pnl::CEvidence *GetPNLEvidence();
</font>
<H5>Discussion</H5>
<p class="description">The function creates an object of pnl::CEvidence class based on the evidence you set. Then the function returns a pointer to the object. You should delete this object yourself. 
</p>
<HR>

<H3><A 
name=decl_Inference_MRF>Inference</A></H3>
<P class=Blurb>Returns a reference to the object of pnl::CInfEngine class which corresponds to the current MRF object 
</P>
<font class="interface">
pnl::CInfEngine &Inference(bool Recreate = false);
</font>
<H5>Arguments</H5>
<DL>
  <DT>Recreate
  <DD>If Recreate variable is equal to true then pnl::CInfEngine object is recreated and the function returns a reference to the new object. </DD></DL>
<H5>Discussion</H5>
<p class="description">The object which the function returns is internal. We do not recommend you to use this method if don't really need it. 
</p>
<HR>

<H3><A 
name=decl_Learning_MRF>Learning</A></H3>
<P class=Blurb>Returns a reference to the object of pnl::CStaticLearningEngine class which corresponds to the current MRF object
</P>
<font class="interface">
pnl::CStaticLearningEngine &Learning();
</font>
<H5>Discussion</H5>
<p class="description">The object which the function returns is internal. We do not recommend you to use this method if don't really need it. 
</p>
<HR>

<H3><A 
name=decl_Model_MRF>Model</A></H3>
<P class=Blurb>Returns a reference to the object of pnl::CMNet class which corresponds to the current MRF object 
</P>
<font class="interface">
pnl::CMNet &Model();
</font>
<H5>Discussion</H5>
<p class="description">The object which the function returns is internal. We do not recommend you to use this method if don't really need it. 
</p>
<HR>

<!--
<H3><A 
name=decl_GetGaussianMean_MRF>GetGaussianMean</A></H3>
<P class=Blurb>Returns mean of gaussian distribution 
</P>
<font class="interface">
TokArr GetGaussianMean(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Name of node whose mean are needed</DD></DL>
<H5>Discussion</H5>
<p class="description">The function returns mean of gaussian distribution. 
</p>
<H5>
Example of usage
</H5>
<p class="example">
TokArr MeanX2 = net.GetGaussianMean("x2");
</p>

<HR>

<H3><A 
name=decl_GetGaussianCovar_MRF>GetGaussianCovar</A></H3>
<P class=Blurb>Returns variance of gaussian distribution 
</P>
<font class="interface">
TokArr GetGaussianCovar(TokArr nodes);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Name of node whose variance are needed. 
</DL>
<H5>Discussion</H5>
<p class="description">The function returns variance of gaussian distribution. 
</p>
<H5>
Example of usage
</H5>
<p class="example">
TokArr CovarX2 = net.GetGaussianCovar("x2");
</P>
<HR>

<H3><A 
name=decl_GetGaussianWeights_MRF>GetGaussianWeights</A></H3>
<P class=Blurb>Returns weights of gaussian distribution. 
</P>
<font class="interface">
TokArr GetGaussianWeights(TokArr nodes, TokArr parent);
</font>
<H5>Arguments</H5>
<DL>
  <DT>nodes
  <DD>Name of node whose weights are needed. 
  <DT>parent
  <DD>A parent of node which weights we are interested in. 
</DL>
<H5>Discussion</H5>
<p class="description">The function returns weights of parent of specified node . 
</p>
<H5>
Example of usage
</H5>
<p class="example">
TokArr WeightsYX2 = net.GetGaussianWeights("y", "x2");
</P>
<HR>
-->

<H3><A 
name=decl_SaveNet_MRF>SaveNet</A></H3>
<P class=Blurb>Saves network to file 
</P>
<font class="interface">
void SaveNet(const char *filename);
</font>
<P>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name.</DD></DL>
<H5>Discussion</H5>
<p class="description">
The function saves network to file of "xml" format with given name. Net structure and nodes
probability distributions are stored to file.
</p>
<H5>
Example of usage
</H5>
<p class="example">
net.SaveNet("net.xml");
</P>
<HR>

<H3><A 
name=decl_SaveEvidBuf_MRF>SaveEvidBuf</A></H3>
<P class=Blurb>Saves evidence buffer content to file 
</P>
<font class="interface">
int SaveEvidBuf(const char *filename, NetConst::ESavingType mode = NetConst::eCSV);
</font>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name. 
  <DT>mode
  <DD>This parameter specifies separating character. Two separating characters are available: ',' (if mode is set to eCSV)
and tab (if mode is set to eTSV).</DD></DL>
<H5>Discussion</H5>
<p class="description">The function saves evidence buffer content to file of "cvs" format. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Save two evidences to file with ',' separator:
</p>
<p class="example">
net.ClearEvidBuf();<br>
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.SaveEvidBuf("evidence1.csv");
</P>
<p class="description">
Save the same two evidences to file with tab separator:
</p>
<p class="example">
net.ClearEvidBuf();<br>
net.AddEvidToBuf("NodeA^true NodeB^false");<br>
net.AddEvidToBuf("NodeA^false NodeC^true");<br>
net.SaveEvidBuf("evidence2.csv", NetConst::eTSV);
</P>
<HR>

<H3><A 
name=decl_LoadNet_MRF>LoadNet</A></H3>
<P class=Blurb>Loads network from file 
</P>
<font class="interface">
void LoadNet(const char *filename);
</font>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function loads network from file with given name. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
The following function call loads net structure and distributions from file "net.xml":
</p>
<p class="example">
net.LoadNet("net.xml");
</P>
<HR>

<H3><A 
name=decl_LoadEvidBuf_MRF>LoadEvidBuf</A></H3>
<P class=Blurb>Loads evidence buffer content from file 
</P>
<pre>
<font class="interface">
int LoadEvidBuf(const char *filename, 
                NetConst::ESavingType mode = NetConst::eCSV, 
                TokArr columns = TokArr());
</font>
</pre>
<H5>Arguments</H5>
<DL>
  <DT>filename
  <DD>File name. 
  <DT>mode
  <DD>Separating character used in file is passed in this parameter. Two separating characters are available: 
',' (if mode is set to eCSV) and tab (if mode is set to eTSV). 
  <DT>columns
  <DD>Names of nodes.</DD></DL>
<H5>Discussion</H5>
<p class="description">The function loads evidence buffer content from file. Buffer is cleared before loading. We can load evidences created in
another net with another node names but with the same values of nodes. To do this we must set new node names in evidences 
using array "columns". The function returns number of evidences loaded from file.
</p>
<H5>
Example of usage
</H5>
<p class="description">
Load evidences from file "evidence1.csv" with ',' separators and perform learning
using them:
</p>
<p class="example">
net.LoadEvidBuf("evidence1.csv");<br>
net.LearnParameters();
</P>
<HR>
<!--
<H3><A 
name=decl_MakeUniformDistribution_MRF>MakeUniformDistribution</A></H3>
<P class=Blurb>Sets uniform distribution on all nodes 
</P>
<font class="interface">
void MakeUniformDistribution();
</font>
<H5>Arguments</H5>
<DL>
</DL>
<H5>Discussion</H5>
<p class="description">The function .... 
</font>
<H5>
Example of usage
</H5>
<p class="example">
</P>
<HR>
-->
<H3><A 
name=decl_GenerateEvidences_MRF>GenerateEvidences</A></H3>
<P class=Blurb>Generate samples for the network 
</P>
<font class="interface">
void GenerateEvidences( int nSamples, bool ignoreCurrEvid = false, TokArr whatNodes = "");
</font>
<H5>Arguments</H5>
<DL>
  <DT>nSamples
  <DD>Number of samples to generate. 
  <DT>ignoreCurrEvid 
  <DD>Flag of current evidence ignorance. If true - the current evidence will be ignored. Default value is false.  
  <DT>whatNodes 
  <DD>Array of variables names to generate and portion of observed data. Default empty array means that all samples will be generated. </DD>
</DL>
<H5>Discussion</H5>
<p class="description">The function generates the specified number of samples from joint probability distribution of the network.
Samples may be generated using the current evidence (which was set with <A href="#decl_EditEvidence_MRF">EditEvidence</A> function)
 or without the current evidence. The function allows generating samples with specified portion of missing variables.
If current evidence is taken into account (ignoreCurrEvid == true), sampled node
values present in evidence
will be equal to values of current evidence. 
The sampled data can be generated so that there will be some portion of missing values - for every node user may specify the portion of 
non-missing values in the generated array.  
The newly generated samples will be added to internal buffer (learning buffer). To clear learning buffer use <A href="#decl_ClearEvidBuf_MRF">ClearEvidBuf</A>. 
</p>
<H5>
Example of usage
</H5>
<p class="description">
Generate 100 samples for all network nodes ignoring current evidence: 
</p>
<p class="example">
GenerateEvidences( 100, true);
</P>
<p class="description">
Generate 100 samples only for nodes "NodeA","NodeB" and "NodeC" using current evidence:
</p>
<p class="example">
TokArr whatNodesToSample = TokArr("NodeA") & "NodeB" & "NodeC";<br>
GenerateEvidences(100, false, whatNodesToSample);
</P>
<p class="description">
Generate 100 samples only for nodes "NodeA","NodeB" and "NodeC" using current evidence. "NodeA" should contain 90% of observed values, "NodeB" and "NodeC" should contain 100% of observed data:
</p>
<p class="example">
    TokArr whatNodesToSample = Tok("NodeA")^0.9 & "NodeB" & Tok("NodeC")^1.0;<br>
    GenerateEvidences( 100, false, whatNodesToSample);
</P>
<p class="description">
Generate 100 samples for nodes "NodeA","NodeB" and "NodeC" using current evidence. All nodes should contain 90% of observed values:
</p>
<p class="example">
    TokArr whatNodesToSample = (Tok("NodeA") "NodeB" & Tok("NodeC") ) ^ 0.9;<br>
    GenerateEvidences( 100, false, whatNodesToSample);
</P>
<p class="description">
Generate 100 samples for all nodes using current evidence. All nodes should contain 90% of observed values:
</p>
<p class="example">
    TokArr whatNodesToSample = 0.9;<br>
    GenerateEvidences( 100, false, whatNodesToSample);
</P>

<HR>
</BODY></HTML>
